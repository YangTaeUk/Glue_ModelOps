# ADR-009: 통합 관측성 및 분산 추적 전략

> **Status**: Accepted
> **Date**: 2024-12-28
> **Author**: SRE Architect
> **Context**: 횡단 관심사 — 전체 시스템(ADR-001~008)을 관통하는 관측성 전략
> **Supersedes**: N/A

---

## TL;DR (한 줄 요약)

> 분산 AI 파이프라인의 디버깅 효율성을 위해 **W3C Trace Context 표준**으로 요청을 추적하고, **PLG Stack(Loki+Promtail+Grafana)**으로 로그를 통합한다. 화려한 대시보드보다 **"Trace ID 하나로 전체 흐름 검색"**이라는 실용적 가치를 우선한다.

---

## 1. 문제 정의 (The Problem)

### 1.1 배경/현황

**이 논의가 왜 시작되었는가?**

우리 시스템은 ADR-001~008에서 정의한 다층 아키텍처를 가진다:

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        현재 시스템 호출 체인                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   [Client]                                                               │
│      │                                                                   │
│      ▼                                                                   │
│   [Nginx] ─────────────────────────────────────────── ADR-001, ADR-008  │
│      │ (Edge Layer, 인증)                                               │
│      ▼                                                                   │
│   [API Gateway] ──────────────────────────────────── ADR-002            │
│      │ (Pipeline Manager)                                                │
│      ▼                                                                   │
│   [Temporal Server] ──────────────────────────────── ADR-003            │
│      │ (Workflow Orchestration)                                          │
│      ▼                                                                   │
│   [Worker] ───────────────────────────────────────── ADR-006            │
│      │ (CPU/Accelerator Worker)                                          │
│      ▼                                                                   │
│   [Connector] ────────────────────────────────────── ADR-004            │
│      │ (Universal Interface)                                             │
│      ▼                                                                   │
│   [Inference Server] ─────────────────────────────── ADR-007            │
│      (vLLM, Triton 등)                                                   │
│                                                                          │
│   ⚠️ 6개 이상의 컴포넌트를 거치는 긴 호출 체인                           │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

**현재 디버깅 방식의 고통:**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   현재 상황: "터미널 지옥"                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   오류 발생! "추론 결과가 안 옵니다"                                     │
│                                                                          │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  현재 디버깅 프로세스:                                          │   │
│   │                                                                  │   │
│   │  터미널 1: docker logs nginx --tail 100 -f                      │   │
│   │  터미널 2: docker logs gateway --tail 100 -f                    │   │
│   │  터미널 3: docker logs temporal --tail 100 -f                   │   │
│   │  터미널 4: docker logs worker --tail 100 -f                     │   │
│   │  터미널 5: docker logs inference-server --tail 100 -f           │   │
│   │                                                                  │   │
│   │  → 5개 창을 번갈아 보면서 타임스탬프로 눈 대중 맞추기           │   │
│   │  → "이 요청이 저 로그랑 같은 요청인가?" 확신 불가               │   │
│   │  → 에러 원인 파악에 30분 이상 소요                               │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
│   근본 원인:                                                             │
│   • 요청 간 연결고리(Correlation) 없음                                  │
│   • 로그가 각 컨테이너에 분산                                           │
│   • 검색/필터링 불가능 (grep으로 한계)                                  │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 핵심 문제

| 현상 (Symptom) | 본질 (Root Cause) |
|---------------|-------------------|
| 어느 컴포넌트에서 오류났는지 모름 | 요청 추적 식별자(Trace ID) 부재 |
| 로그 검색이 어려움 | 로그가 각 컨테이너에 분산 저장 |
| 타임스탬프 대조로 시간 낭비 | 구조화된 로그 포맷 없음 |
| 디버깅 시간 > 수정 시간 | 관측성(Observability) 체계 부재 |

### 1.3 비즈니스 임팩트

**해결하지 않으면:**

| 영향 | 설명 |
|------|------|
| **장애 대응 지연** | 원인 파악에 30분 이상 → SLA 위반 위험 |
| **개발 생산성 저하** | 디버깅 시간이 개발 시간을 잠식 |
| **지식 속인화** | "그 로그는 여기 봐야 해" — 특정 인원만 문제 해결 가능 |
| **재현 불가** | 문제 상황을 정확히 재구성할 수 없음 |

### 1.4 제약 조건

| 제약 | 설명 | 영향 |
|------|------|------|
| **예산** | ELK(Elasticsearch), Datadog 등 유료/고비용 솔루션 불가 | 오픈소스 필수 |
| **인프라** | Docker Compose 환경 | K8s 전용 솔루션 배제 |
| **리소스** | 관측 시스템이 본 시스템보다 무거우면 안 됨 | 경량화 우선 |
| **팀 규모** | 전담 SRE 없음 | 운영 단순성 필수 |

---

## 2. 전략적 결정

> **Why/What 원칙**: ADR은 "무엇을" 결정하고, "어떻게"는 설계 문서로 위임한다.

### 2.1 결정 #1: W3C Trace Context 표준 채택

> **"하나의 Trace ID로 전체 요청 흐름을 추적한다"**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   Trace Context Propagation                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   [표준 선택: W3C Trace Context]                                        │
│   ──────────────────────────────                                        │
│                                                                          │
│   헤더 포맷: traceparent                                                │
│   예시: 00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01         │
│              │                              │                  │        │
│              └─ Trace ID (32자)             └─ Span ID (16자)  └─ Flag  │
│                 (요청 전체 식별)               (현재 단계 식별)          │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────     │
│                                                                          │
│   [전파 흐름]                                                            │
│   ───────────                                                            │
│                                                                          │
│   ① Nginx (Edge Layer)                                                  │
│      └─ traceparent 헤더 없으면 생성                                    │
│      └─ 있으면 그대로 전달                                              │
│      └─ X-Request-ID로도 동일 값 복사 (하위 호환)                       │
│                                                                          │
│   ② API Gateway                                                         │
│      └─ traceparent 수신                                                │
│      └─ 로그에 trace_id 기록                                            │
│      └─ Temporal Workflow 시작 시 trace_id를 메타데이터로 전달          │
│                                                                          │
│   ③ Temporal Worker                                                     │
│      └─ Workflow 메타데이터에서 trace_id 추출                           │
│      └─ 모든 Activity 로그에 trace_id 포함                              │
│      └─ Connector 호출 시 traceparent 헤더로 전달                       │
│                                                                          │
│   ④ Connector → Inference Server                                        │
│      └─ HTTP 호출 시 traceparent 헤더 전달                              │
│      └─ 추론 서버 응답 로그와 연결 가능                                 │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

**왜 W3C Trace Context인가:**

| 근거 | 설명 |
|------|------|
| **업계 표준** | OpenTelemetry, Jaeger, Zipkin 등 모든 주요 도구가 지원 |
| **벤더 중립** | 특정 APM 솔루션에 종속되지 않음 |
| **확장성** | 추후 분산 추적 백엔드(Jaeger 등) 도입 시 코드 변경 최소화 |
| **단순성** | HTTP 헤더 하나로 구현 가능 |

**ADR-008과의 관계:**

```
ADR-008에서 정의한 X-Client-ID와 trace_id는 별개의 관심사:

X-Client-ID: "누가" 요청했는가 (인증, 감사)
trace_id:    "어떤 요청"인가 (추적, 디버깅)

둘 다 Nginx에서 주입하여 Backend로 전달
```

### 2.2 결정 #2: PLG Stack 채택 (Loki + Promtail + Grafana)

> **"ELK의 기능은 80%만, 리소스는 20%만 사용한다"**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   PLG Stack Architecture                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   [구성 요소]                                                            │
│   ───────────                                                            │
│                                                                          │
│   ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                    │
│   │  Promtail   │  │    Loki     │  │   Grafana   │                    │
│   │  (수집기)   │  │  (저장소)   │  │  (시각화)   │                    │
│   │             │  │             │  │             │                    │
│   │ • 로그 수집 │  │ • 인덱스    │  │ • 대시보드  │                    │
│   │ • 라벨 부착 │  │   최소화    │  │ • 로그 탐색 │                    │
│   │ • 포워딩    │  │ • 압축 저장 │  │ • 알림      │                    │
│   └──────┬──────┘  └──────┬──────┘  └──────┬──────┘                    │
│          │                │                │                            │
│          └────────────────┴────────────────┘                            │
│                           │                                              │
│                    로그 파이프라인                                       │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────     │
│                                                                          │
│   [ELK vs PLG 비교]                                                     │
│   ─────────────────                                                     │
│                                                                          │
│                        ELK Stack              PLG Stack                 │
│                        ─────────              ─────────                 │
│   메모리 사용          4~8GB (ES만)           256MB~1GB (전체)          │
│   인덱싱 방식          Full-text 인덱싱       라벨 기반 (인덱스 최소화)  │
│   검색 성능            복잡한 쿼리 우수       단순 쿼리 충분             │
│   스토리지 효율        낮음 (인덱스 비대)     높음 (압축)               │
│   Docker Compose       복잡 (클러스터 권장)   단순 (단일 인스턴스 OK)    │
│   비용                 무거움                 경량                      │
│                                                                          │
│   결론: 우리 규모에서 ELK는 오버스펙                                     │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

**왜 PLG Stack인가:**

| 근거 | 설명 |
|------|------|
| **리소스 효율** | Loki는 로그 내용을 인덱싱하지 않음 → 메모리/스토리지 절감 |
| **Docker 친화** | docker-compose.yml에 3개 서비스 추가로 구축 완료 |
| **Grafana 통합** | 메트릭(Prometheus)과 로그(Loki)를 동일 UI에서 확인 |
| **충분한 기능** | 라벨 기반 필터링 + grep 스타일 검색으로 디버깅 충분 |

**기각된 대안:**

| 대안 | 기각 사유 |
|------|----------|
| **ELK Stack** | 리소스 과다, 운영 복잡도 높음 |
| **Datadog/New Relic** | 유료, 비용 제약 |
| **CloudWatch** | 클라우드 종속, 비용 제약 |
| **stdout만 사용** | 검색/필터링 불가, 현재의 고통 지속 |

### 2.3 결정 #3: 구조화된 로깅 (Structured Logging)

> **"사람이 읽는 로그가 아닌, 기계가 파싱하는 로그를 출력한다"**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   Structured Logging Standard                           │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   [Before: 비구조화 로그]                                               │
│   ───────────────────────                                               │
│                                                                          │
│   2024-12-28 10:15:23 INFO Starting inference for user request          │
│   2024-12-28 10:15:24 ERROR Model timeout after 30s                     │
│                                                                          │
│   문제점:                                                                │
│   • trace_id 없음 → 어떤 요청인지 모름                                  │
│   • component 없음 → 어느 서비스 로그인지 모름                          │
│   • 파싱 어려움 → 자동화 불가                                           │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────     │
│                                                                          │
│   [After: 구조화 로그 (JSON)]                                           │
│   ───────────────────────────                                           │
│                                                                          │
│   {                                                                      │
│     "timestamp": "2024-12-28T10:15:23.456Z",                            │
│     "level": "INFO",                                                     │
│     "message": "Starting inference for user request",                   │
│     "trace_id": "0af7651916cd43dd8448eb211c80319c",                     │
│     "span_id": "b7ad6b7169203331",                                      │
│     "component": "worker",                                               │
│     "client_id": "dept-a",                                               │
│     "pipeline_id": "text-embedding-v1",                                  │
│     "extra": { "model": "bge-large", "input_length": 512 }              │
│   }                                                                      │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────     │
│                                                                          │
│   [필수 필드 정의]                                                       │
│   ────────────────                                                       │
│                                                                          │
│   필드           설명                        예시                        │
│   ─────          ─────                       ─────                       │
│   timestamp      ISO 8601 형식               2024-12-28T10:15:23.456Z   │
│   level          로그 레벨                   DEBUG/INFO/WARN/ERROR      │
│   message        로그 메시지                 자유 형식                   │
│   trace_id       W3C Trace ID (32자)         0af7651916cd...            │
│   component      서비스/컴포넌트 이름        nginx/gateway/worker       │
│                                                                          │
│   [권장 필드]                                                            │
│   ────────────                                                           │
│   span_id        현재 스팬 ID (16자)         b7ad6b71692...             │
│   client_id      요청자 식별 (ADR-008)       dept-a                     │
│   pipeline_id    파이프라인 식별자           text-embedding-v1          │
│   duration_ms    처리 시간                   1523                       │
│   extra          추가 컨텍스트 (자유 형식)   { "model": "..." }         │
│                                                                          │
│   (구체적인 로깅 라이브러리 선택과 설정은 설계 문서에서 정의)            │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

**Grafana에서의 활용:**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   Grafana Loki Query Example                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   [시나리오: 특정 요청의 전체 흐름 추적]                                 │
│                                                                          │
│   쿼리:                                                                  │
│   {component=~".+"} |= "0af7651916cd43dd8448eb211c80319c"               │
│                                                                          │
│   결과: 해당 trace_id를 포함한 모든 컴포넌트의 로그가 시간순 정렬       │
│                                                                          │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  10:15:23.100  nginx     Request received, assigned trace_id    │   │
│   │  10:15:23.150  gateway   Pipeline started: text-embedding-v1    │   │
│   │  10:15:23.200  temporal  Workflow created: wf-12345             │   │
│   │  10:15:23.250  worker    Activity started: preprocess           │   │
│   │  10:15:23.500  worker    Activity completed: preprocess         │   │
│   │  10:15:23.550  connector Calling inference server               │   │
│   │  10:15:24.800  connector Response received, 1250ms              │   │
│   │  10:15:24.850  worker    Activity completed: inference          │   │
│   │  10:15:24.900  gateway   Pipeline completed, total 1800ms       │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
│   → 단일 Trace ID로 전체 요청 생애주기 재구성                           │
│   → "어디서 오래 걸렸는가?" 즉시 파악 (connector: 1250ms)               │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 3. 아키텍처 개요

### 3.1 로그 수집 흐름

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   Log Collection Architecture                           │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   [Application Layer]                                                    │
│   ────────────────────                                                   │
│                                                                          │
│   ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐          │
│   │  Nginx  │ │ Gateway │ │ Worker  │ │Connector│ │Inference│          │
│   └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘          │
│        │           │           │           │           │                │
│        │ JSON logs │ JSON logs │ JSON logs │ JSON logs │ (native)       │
│        ▼           ▼           ▼           ▼           ▼                │
│   ┌─────────────────────────────────────────────────────────────┐      │
│   │                     Docker Log Driver                        │      │
│   │                     (json-file, default)                     │      │
│   └─────────────────────────────────────────────────────────────┘      │
│                                    │                                    │
│                                    │ /var/lib/docker/containers/*/     │
│                                    ▼                                    │
│   ─────────────────────────────────────────────────────────────────    │
│                                                                          │
│   [Collection Layer]                                                     │
│   ───────────────────                                                    │
│                                                                          │
│   ┌─────────────────────────────────────────────────────────────┐      │
│   │                        Promtail                              │      │
│   │                                                              │      │
│   │  • Docker 로그 파일 모니터링                                 │      │
│   │  • 컨테이너 라벨에서 메타데이터 추출                        │      │
│   │  • component 라벨 자동 부착                                  │      │
│   │  • Loki로 스트리밍 전송                                      │      │
│   └─────────────────────────────────────────────────────────────┘      │
│                                    │                                    │
│                                    │ HTTP Push (batch)                  │
│                                    ▼                                    │
│   ─────────────────────────────────────────────────────────────────    │
│                                                                          │
│   [Storage Layer]                                                        │
│   ────────────────                                                       │
│                                                                          │
│   ┌─────────────────────────────────────────────────────────────┐      │
│   │                          Loki                                │      │
│   │                                                              │      │
│   │  • 라벨 인덱싱 (component, level 등)                        │      │
│   │  • 로그 내용은 압축 저장 (인덱싱 안 함)                     │      │
│   │  • 보관 주기: 7일 (설정 가능)                               │      │
│   └─────────────────────────────────────────────────────────────┘      │
│                                    │                                    │
│                                    │ LogQL                              │
│                                    ▼                                    │
│   ─────────────────────────────────────────────────────────────────    │
│                                                                          │
│   [Visualization Layer]                                                  │
│   ──────────────────────                                                 │
│                                                                          │
│   ┌─────────────────────────────────────────────────────────────┐      │
│   │                        Grafana                               │      │
│   │                                                              │      │
│   │  • Loki 데이터소스 연결                                     │      │
│   │  • Explore: trace_id 검색, 로그 탐색                        │      │
│   │  • Dashboard: 에러율, 응답시간 시각화                       │      │
│   │  • Alerting: 에러 급증 시 알림                              │      │
│   └─────────────────────────────────────────────────────────────┘      │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Trace Context 전파 흐름

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   Trace Context Propagation Flow                        │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   [Client Request]                                                       │
│        │                                                                 │
│        │ (traceparent 없음)                                             │
│        ▼                                                                 │
│   ┌─────────────────────────────────────────────────────────────┐      │
│   │  Nginx                                                       │      │
│   │  ─────                                                       │      │
│   │  if ($http_traceparent = "") {                              │      │
│   │      set $trace_id = generate_uuid();                       │      │
│   │      set $traceparent = "00-{$trace_id}-{$span_id}-01";    │      │
│   │  }                                                           │      │
│   │  proxy_set_header traceparent $traceparent;                 │      │
│   │  proxy_set_header X-Request-ID $trace_id;                   │      │
│   └─────────────────────────────────────────────────────────────┘      │
│        │                                                                 │
│        │ traceparent: 00-abc123...-def456...-01                        │
│        │ X-Request-ID: abc123...                                        │
│        │ X-Client-ID: dept-a (ADR-008)                                  │
│        ▼                                                                 │
│   ┌─────────────────────────────────────────────────────────────┐      │
│   │  API Gateway (FastAPI)                                       │      │
│   │  ────────────────────────                                    │      │
│   │  trace_id = request.headers.get("X-Request-ID")             │      │
│   │  logger.info("Request received", trace_id=trace_id)         │      │
│   │                                                              │      │
│   │  # Temporal Workflow 시작 시                                 │      │
│   │  workflow.start(                                             │      │
│   │      ...,                                                    │      │
│   │      search_attributes={"trace_id": trace_id}               │      │
│   │  )                                                           │      │
│   └─────────────────────────────────────────────────────────────┘      │
│        │                                                                 │
│        │ Temporal Workflow Metadata                                     │
│        ▼                                                                 │
│   ┌─────────────────────────────────────────────────────────────┐      │
│   │  Worker                                                      │      │
│   │  ──────                                                      │      │
│   │  trace_id = workflow.info().search_attributes["trace_id"]   │      │
│   │  logger.info("Activity started", trace_id=trace_id)         │      │
│   │                                                              │      │
│   │  # Connector 호출 시                                         │      │
│   │  connector.invoke(                                           │      │
│   │      ...,                                                    │      │
│   │      headers={"traceparent": build_traceparent(trace_id)}   │      │
│   │  )                                                           │      │
│   └─────────────────────────────────────────────────────────────┘      │
│        │                                                                 │
│        │ traceparent 헤더                                               │
│        ▼                                                                 │
│   ┌─────────────────────────────────────────────────────────────┐      │
│   │  Inference Server                                            │      │
│   │  ────────────────                                            │      │
│   │  (가능하면) 로그에 trace_id 포함                            │      │
│   │  (불가능하면) Connector 측에서 요청/응답 로그로 커버         │      │
│   └─────────────────────────────────────────────────────────────┘      │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 4. 트레이드오프 및 제약

### 4.1 감수하는 단점

| 단점 | 영향 | 보완 전략 |
|------|------|----------|
| **Full-text 검색 제한** | Loki는 로그 내용 인덱싱 안 함, 복잡한 검색 느림 | 라벨 기반 필터링 + grep 스타일 검색으로 대부분 커버 |
| **분산 추적 백엔드 없음** | Jaeger 같은 Trace UI 없음, 스팬 시각화 불가 | 로그 기반 추적으로 충분, 추후 필요 시 Jaeger 추가 |
| **로깅 오버헤드** | 모든 로그에 trace_id 포함 → 약간의 CPU/네트워크 증가 | 무시할 수준, 디버깅 효율성이 압도적으로 중요 |
| **단일 장애점** | Loki/Grafana 다운 시 로그 조회 불가 | docker logs 백업 수단 존재, 로그 자체는 유실 안 됨 |

### 4.2 확장 경로 (Future Path)

| 현재 결정 | 확장 가능 방향 | 트리거 |
|----------|---------------|--------|
| **Trace ID 전파만** | Jaeger/Tempo로 분산 추적 백엔드 추가 | 스팬 시각화 필요 시 |
| **Loki 단일 인스턴스** | Loki 클러스터링 | 로그 볼륨 폭증 시 |
| **Grafana 알림** | PagerDuty/Slack 연동 | On-call 체계 구축 시 |
| **로그만** | Prometheus 메트릭 추가 | SLI/SLO 정의 필요 시 |

### 4.3 재검토 트리거

다음 상황 발생 시 이 결정을 재검토한다:

- [ ] 로그 볼륨이 일 10GB 이상으로 증가
- [ ] Full-text 검색 빈번하게 필요해짐
- [ ] Kubernetes로 인프라 전환
- [ ] 전담 SRE 인력 확보
- [ ] 스팬 단위 시각화 필요성 대두

---

## 5. 결론

### 5.1 최종 결정 요약

| 결정 항목 | 결정 내용 | 핵심 논거 |
|----------|----------|----------|
| **추적 표준** | W3C Trace Context | 업계 표준, 벤더 중립, 확장성 |
| **로그 스택** | PLG (Loki+Promtail+Grafana) | 경량, Docker 친화, 비용 효율 |
| **로그 포맷** | JSON 구조화 로깅 | 파싱 용이, 필터링 가능 |
| **필수 필드** | timestamp, level, message, trace_id, component | 최소한의 추적 가능 정보 |

### 5.2 핵심 메시지

> **"화려한 대시보드보다 Trace ID 하나로 검색되는 것이 더 가치 있다."**

이 결정은:
- **터미널 5개 대신 Grafana 1개**로 디버깅
- 오류 원인 파악 시간 **30분 → 5분** 단축
- ELK 대비 **1/10 리소스**로 충분한 관측성 확보
- **실용주의적 선택**: 완벽한 APM보다 "지금 당장 쓸 수 있는" 것

---

## 관련 문서 (Related)

**관련 결정 (횡단 관심사로서 참조):**
- [ADR-001: AI 서비스 엔드포인트 노출 (Nginx)](./001_How_to_Securely_Expose_AI_API_Endpoint_[Nginx%20OSS].md) — Trace ID 생성 주체
- [ADR-003: 추론 작업 실행 모델 (Temporal)](./003_Inference_Task_Execution_Model_and_State_Management_Strategy.md) — Workflow 메타데이터로 trace_id 전파
- [ADR-004: Universal Connector](./004_Universal_Connector_Strategy_for_Model_Integration.md) — 추론 서버 호출 시 trace_id 전달
- [ADR-008: 시스템 클라이언트 인증](./008_System_Client_Authentication_and_Access_Control_Strategy.md) — X-Client-ID와 trace_id 동시 전파

**설계/운영 문서:**
- [04_operations/03_monitoring.md](../04_operations/03_monitoring.md) — PLG Stack 구성 상세, 대시보드 설정
- [03_development/01_setup.md](../03_development/01_setup.md) — 로깅 라이브러리 설정 가이드

---

## 변경 이력 (Changelog)

| 날짜 | 작성자 | 변경 내용 |
|------|--------|----------|
| 2024-12-28 | SRE Architect | 초안 작성 |
