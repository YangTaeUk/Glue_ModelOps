# ADR-010: 백엔드 애플리케이션 프레임워크 선정

> **Status**: Accepted
> **Date**: 2024-12-28
> **Author**: Senior Backend Engineer
> **Context**: [ADR-002](./002_Defining_Scope_and_Architecture_Style_of_AI_Backend_Application.md), [ADR-003](./003_Inference_Task_Execution_Model_and_State_Management_Strategy.md), [ADR-005](./005_Realtime_Streaming_Channel_Strategy.md) 후속 결정 — 아키텍처 요구사항을 충족하는 프레임워크 선정
> **Supersedes**: N/A

---

## TL;DR (한 줄 요약)

> FastAPI는 "유행하는 프레임워크"여서 선택한 것이 아니다. **ADR-003(Temporal 비동기)**, **ADR-005(SSE 스트리밍)**, **ADR-002(스키마 검증)** 요구사항을 동시에 만족하는 **유일한 기술적 대안**이기 때문에 선택한다.

---

## 1. 문제 정의 (The Problem)

### 1.1 배경/현황

**이 논의가 왜 시작되었는가?**

앞서 결정된 아키텍처는 백엔드 프레임워크에 **특정 제약**을 부과한다. 이 제약을 충족하지 못하는 프레임워크를 선택하면, 아키텍처 전체가 무너지거나 복잡한 우회로가 필요해진다.

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   선행 ADR이 부과하는 제약 조건                          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   [ADR-003: Temporal 채택]                                              │
│   ─────────────────────────                                             │
│   • Temporal Client는 async I/O 기반                                   │
│   • Workflow 시작, 상태 조회, Signal 전송 = 모두 네트워크 호출          │
│   • 동기 프레임워크에서는 매 호출마다 스레드 블로킹                     │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────     │
│                                                                          │
│   [ADR-005: SSE 스트리밍]                                               │
│   ─────────────────────────                                             │
│   • LLM 토큰 스트리밍 = 장시간 연결 유지 (수십 초)                      │
│   • 동기 워커: 1 연결 = 1 스레드 점유                                   │
│   • 100개 동시 스트리밍 = 100개 스레드 고갈                             │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────     │
│                                                                          │
│   [ADR-002: 파이프라인 매니저]                                          │
│   ─────────────────────────────                                         │
│   • 복잡한 파이프라인 정의 (다단계, 파라미터)                           │
│   • 모델별 입출력 스키마 상이                                           │
│   • 런타임 검증 없이는 잘못된 요청이 추론 서버까지 도달                 │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────     │
│                                                                          │
│   ⚠️ 결론: 프레임워크 선택은 "취향"이 아니라 "아키텍처 적합성"의 문제   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 핵심 문제

| 현상 (Symptom) | 본질 (Root Cause) |
|---------------|-------------------|
| Temporal 호출 시 응답 지연 | 동기 프레임워크가 I/O 대기 중 스레드 블로킹 |
| SSE 동시 연결 수 제한 | 워커 프로세스/스레드 고갈 |
| 잘못된 요청이 추론 서버 도달 | 런타임 스키마 검증 부재 |
| API 문서 수동 관리 | 자동 문서화 기능 없음 |

### 1.3 비즈니스 임팩트

**잘못된 프레임워크 선택 시:**

| 영향 | 설명 |
|------|------|
| **동시성 붕괴** | 100명 동시 접속 시 시스템 마비 (스레드 고갈) |
| **GPU 낭비** | 잘못된 파라미터가 추론 서버까지 도달 → 에러 후 GPU 시간 낭비 |
| **우회로 복잡도** | 비동기 지원을 위한 Celery, gevent 등 추가 스택 도입 |
| **개발 생산성 저하** | 수동 검증 코드, 수동 문서 관리 |

### 1.4 필수 요구사항 정리

프레임워크가 반드시 충족해야 하는 조건:

| # | 요구사항 | 출처 | 필수 여부 |
|---|----------|------|----------|
| R1 | **Native Async I/O** | ADR-003 (Temporal) | 필수 |
| R2 | **SSE 스트리밍 효율성** | ADR-005 (Dual Path) | 필수 |
| R3 | **런타임 스키마 검증** | ADR-002 (Pipeline) | 필수 |
| R4 | 자동 API 문서화 | 운영 편의 | 권장 |
| R5 | AI 생태계 호환성 | 통합 용이성 | 권장 |

---

## 2. 대안 분석 (Alternatives Analysis)

### 2.1 WSGI vs ASGI: 근본적 차이

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   WSGI vs ASGI: 동시성 모델 비교                        │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   [WSGI (Flask, Django 기본)]                                           │
│   ───────────────────────────                                           │
│                                                                          │
│   Request 1 ──▶ [Worker Thread 1] ──▶ 처리 (블로킹) ──▶ 응답            │
│   Request 2 ──▶ [Worker Thread 2] ──▶ 처리 (블로킹) ──▶ 응답            │
│   Request 3 ──▶ [Worker Thread 3] ──▶ 처리 (블로킹) ──▶ 응답            │
│   Request 4 ──▶ [대기...] (모든 스레드 점유 중)                         │
│                                                                          │
│   문제:                                                                  │
│   • 스레드 수 = 동시 처리 가능 수                                       │
│   • I/O 대기 중에도 스레드 점유                                         │
│   • SSE 장시간 연결 시 스레드 고갈                                      │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────     │
│                                                                          │
│   [ASGI (FastAPI, Starlette)]                                           │
│   ───────────────────────────                                           │
│                                                                          │
│   Request 1 ──┐                                                          │
│   Request 2 ──┼──▶ [Event Loop] ──▶ 비동기 처리 ──▶ 응답                │
│   Request 3 ──┤      │                                                   │
│   Request 4 ──┘      └── I/O 대기 시 다른 요청 처리                     │
│                                                                          │
│   장점:                                                                  │
│   • 단일 프로세스로 수천 동시 연결 처리 가능                            │
│   • I/O 대기 시간을 다른 요청 처리에 활용                               │
│   • SSE/WebSocket 자연스럽게 지원                                       │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 대안 A: Flask — ❌ 기각

**개요**: Python 웹 프레임워크의 "마이크로" 대표주자. 단순함과 유연성이 장점.

**매력적인 이유:**
- 학습 곡선 낮음
- 광범위한 생태계
- 경량

**기각 사유:**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        Flask 기각 논거                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   [문제 1: WSGI 기반 — 본질적 한계]                                     │
│   ─────────────────────────────────                                     │
│                                                                          │
│   Flask 2.0+에서 async def 지원 추가됨.                                 │
│   그러나 이것은 "진정한 비동기"가 아님:                                 │
│                                                                          │
│   @app.route('/api')                                                    │
│   async def handler():                                                  │
│       result = await some_async_call()  # ← 여기서                      │
│       return result                                                      │
│                                                                          │
│   → Flask는 내부적으로 asyncio.run()을 호출                             │
│   → 각 요청마다 새 이벤트 루프 생성 (오버헤드)                          │
│   → 기존 동기 미들웨어/확장과 충돌 가능                                 │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────     │
│                                                                          │
│   [문제 2: SSE 구현의 비효율]                                           │
│   ──────────────────────────                                            │
│                                                                          │
│   Flask에서 SSE 구현:                                                   │
│   • flask-sse 등 확장 필요                                              │
│   • Gunicorn + gevent 워커 필요 (동기 워커로는 불가)                    │
│   • 그래도 ASGI 대비 효율 떨어짐                                        │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────     │
│                                                                          │
│   [문제 3: 데이터 검증 별도 구현]                                       │
│   ──────────────────────────────                                        │
│                                                                          │
│   # Flask 방식 (수동)                                                   │
│   from marshmallow import Schema, fields                                │
│                                                                          │
│   class PipelineSchema(Schema):                                         │
│       name = fields.Str(required=True)                                  │
│       stages = fields.List(fields.Nested(StageSchema))                  │
│                                                                          │
│   @app.route('/api', methods=['POST'])                                  │
│   def handler():                                                        │
│       schema = PipelineSchema()                                         │
│       errors = schema.validate(request.json)  # 수동 검증               │
│       if errors:                                                        │
│           return jsonify(errors), 400                                   │
│       data = schema.load(request.json)  # 수동 로드                     │
│       ...                                                                │
│                                                                          │
│   → 검증 로직이 비즈니스 로직과 분리되지 않음                           │
│   → 보일러플레이트 코드 증가                                            │
│   → OpenAPI 문서 자동 생성 안 됨                                        │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

**R1~R5 충족 여부:**

| 요구사항 | 충족 | 비고 |
|----------|------|------|
| R1 Native Async | ⚠️ 부분 | 진정한 비동기 아님 |
| R2 SSE 효율성 | ❌ | gevent 필요, 여전히 비효율 |
| R3 스키마 검증 | ⚠️ 부분 | Marshmallow 별도 설치 |
| R4 자동 문서화 | ❌ | flasgger 등 별도 설치 |
| R5 AI 생태계 | ⚠️ 부분 | 레거시 중심 |

### 2.3 대안 B: Django — ❌ 기각

**개요**: Python 웹 프레임워크의 "풀스택" 대표주자. "Batteries Included" 철학.

**매력적인 이유:**
- ORM, Admin, 인증 등 내장
- 성숙한 생태계
- 대규모 프로젝트 검증

**기각 사유:**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        Django 기각 논거                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   [문제 1: 불필요한 오버헤드]                                           │
│   ──────────────────────────                                            │
│                                                                          │
│   ADR-002에서 정의한 우리 시스템의 역할:                                │
│   ────────────────────────────────────                                  │
│   "Atomic AI Pipeline Manager"                                          │
│                                                                          │
│   필요한 것:                          Django가 제공하는 것:             │
│   ─────────────                       ─────────────────────              │
│   • API 라우팅                        • Admin 패널 ❌                   │
│   • 비동기 I/O                        • ORM (SQLAlchemy 선호) ❌        │
│   • 스키마 검증                       • Template 엔진 ❌                │
│   • Temporal 통합                     • 세션/쿠키 관리 ❌               │
│                                       • 폼 처리 ❌                       │
│                                                                          │
│   → Django 기능의 80%를 사용하지 않음                                   │
│   → "선탑재된 기능"이 오히려 부채                                       │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────     │
│                                                                          │
│   [문제 2: ASGI 전환 복잡도]                                            │
│   ──────────────────────────                                            │
│                                                                          │
│   Django 3.0+에서 ASGI 지원 추가됨.                                     │
│   그러나:                                                                │
│   • 대부분의 Django 확장이 동기 기반                                    │
│   • ORM이 동기 → 비동기 쿼리는 별도 문법                                │
│   • 기존 미들웨어 호환성 문제                                           │
│                                                                          │
│   # Django 비동기 ORM (추가 복잡도)                                     │
│   from asgiref.sync import sync_to_async                                │
│                                                                          │
│   @sync_to_async                                                        │
│   def get_user(user_id):                                                │
│       return User.objects.get(id=user_id)                               │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────     │
│                                                                          │
│   [문제 3: AI 생태계 미스매치]                                          │
│   ────────────────────────────                                          │
│                                                                          │
│   • vLLM → FastAPI 예제 공식 제공                                       │
│   • LangChain → FastAPI 통합 가이드                                     │
│   • Hugging Face → FastAPI 기반 Inference API                           │
│   • Django 기반 AI 예제 → 거의 없음                                     │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

**R1~R5 충족 여부:**

| 요구사항 | 충족 | 비고 |
|----------|------|------|
| R1 Native Async | ⚠️ 부분 | ASGI 지원하나 생태계 동기 중심 |
| R2 SSE 효율성 | ⚠️ 부분 | Django Channels 필요 |
| R3 스키마 검증 | ⚠️ 부분 | DRF Serializers, Pydantic 별도 |
| R4 자동 문서화 | ⚠️ 부분 | DRF + drf-spectacular 필요 |
| R5 AI 생태계 | ❌ | AI 도구들이 Django 미지원 |

### 2.4 대안 C: FastAPI — ✅ 채택

**개요**: 현대적 Python 웹 프레임워크. ASGI 네이티브, Pydantic 기반 타입 안전성.

**선택 이유:**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        FastAPI 채택 논거                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   [강점 1: Native Async — ADR-003 충족]                                 │
│   ─────────────────────────────────────                                 │
│                                                                          │
│   FastAPI는 ASGI(Starlette) 기반으로 설계됨.                            │
│   "비동기를 추가한 것"이 아니라 "비동기로 시작한 것":                    │
│                                                                          │
│   @app.post("/pipeline")                                                │
│   async def start_pipeline(request: PipelineRequest):                   │
│       # Temporal Client 호출 — Non-blocking                             │
│       handle = await temporal_client.start_workflow(                    │
│           "InferencePipeline",                                          │
│           request.dict(),                                               │
│           id=request.job_id                                             │
│       )                                                                  │
│       return {"job_id": request.job_id, "status": "started"}            │
│                                                                          │
│   → I/O 대기 중 다른 요청 처리 가능                                     │
│   → 스레드 블로킹 없음                                                  │
│   → Temporal Python SDK와 자연스러운 통합                               │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────     │
│                                                                          │
│   [강점 2: SSE 네이티브 지원 — ADR-005 충족]                            │
│   ──────────────────────────────────────────                            │
│                                                                          │
│   from sse_starlette.sse import EventSourceResponse                     │
│                                                                          │
│   @app.get("/stream/{job_id}")                                          │
│   async def stream_result(job_id: str):                                 │
│       async def event_generator():                                      │
│           async for token in get_tokens(job_id):                        │
│               yield {"data": token}                                     │
│       return EventSourceResponse(event_generator())                     │
│                                                                          │
│   → 100개 동시 SSE 연결도 단일 프로세스에서 처리                        │
│   → 각 연결이 스레드를 점유하지 않음                                    │
│   → 메모리 효율적                                                       │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────     │
│                                                                          │
│   [강점 3: Pydantic 통합 — ADR-002 충족]                                │
│   ─────────────────────────────────────                                 │
│                                                                          │
│   from pydantic import BaseModel, Field                                 │
│                                                                          │
│   class InferenceRequest(BaseModel):                                    │
│       model_id: str = Field(..., pattern=r"^[a-z0-9-]+$")              │
│       prompt: str = Field(..., min_length=1, max_length=4096)          │
│       parameters: ModelParameters                                       │
│                                                                          │
│   @app.post("/inference")                                               │
│   async def inference(request: InferenceRequest):                       │
│       # request는 이미 검증 완료                                        │
│       # 잘못된 요청은 여기 도달 전에 422 반환                           │
│       ...                                                                │
│                                                                          │
│   장점:                                                                  │
│   • 선언적 검증 — 비즈니스 로직과 분리                                  │
│   • 자동 타입 변환                                                      │
│   • IDE 자동완성 지원                                                   │
│   • OpenAPI 스키마 자동 생성                                            │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────     │
│                                                                          │
│   [강점 4: 자동 API 문서화]                                             │
│   ─────────────────────────                                             │
│                                                                          │
│   추가 설정 없이 자동 생성:                                              │
│   • /docs — Swagger UI                                                  │
│   • /redoc — ReDoc                                                      │
│   • /openapi.json — OpenAPI 스키마                                      │
│                                                                          │
│   → 코드가 곧 문서                                                      │
│   → 문서와 구현의 불일치 방지                                           │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────     │
│                                                                          │
│   [강점 5: AI 생태계 표준]                                              │
│   ─────────────────────────                                             │
│                                                                          │
│   • vLLM: FastAPI 기반 OpenAI-compatible 서버                           │
│   • LangServe: LangChain + FastAPI 통합                                 │
│   • Hugging Face TGI: FastAPI 호환 API                                  │
│   • Triton: FastAPI 예제 공식 제공                                      │
│   • OpenAI API: FastAPI 스타일 설계                                     │
│                                                                          │
│   → AI 도구들이 FastAPI를 "기본 프레임워크"로 가정                      │
│   → 통합 코드가 이미 존재                                               │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

**R1~R5 충족 여부:**

| 요구사항 | 충족 | 비고 |
|----------|------|------|
| R1 Native Async | ✅ | ASGI 네이티브 |
| R2 SSE 효율성 | ✅ | sse-starlette 통합 |
| R3 스키마 검증 | ✅ | Pydantic 내장 |
| R4 자동 문서화 | ✅ | OpenAPI 자동 생성 |
| R5 AI 생태계 | ✅ | 업계 표준 |

---

## 3. 결정 사항

### 3.1 최종 결정

> **"FastAPI를 백엔드 애플리케이션 프레임워크로 채택한다."**

### 3.2 대안 비교 요약

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         프레임워크 비교 매트릭스                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   요구사항             Flask      Django     FastAPI                    │
│   ─────────            ─────      ──────     ───────                    │
│                                                                          │
│   R1 Native Async      ⚠️ 부분    ⚠️ 부분    ✅ 완전                    │
│   R2 SSE 효율성        ❌         ⚠️ 부분    ✅ 완전                    │
│   R3 스키마 검증       ⚠️ 별도    ⚠️ 별도    ✅ 내장                    │
│   R4 자동 문서화       ❌         ⚠️ 별도    ✅ 내장                    │
│   R5 AI 생태계         ⚠️ 레거시  ❌         ✅ 표준                    │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────     │
│                                                                          │
│   결론:                                                                  │
│   • Flask: 비동기/SSE 요구사항 미충족                                   │
│   • Django: 오버스펙 + AI 생태계 미스매치                               │
│   • FastAPI: 모든 필수 요구사항 충족 — 유일한 대안                      │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.3 ADR-008과의 시너지

ADR-008에서 인증 책임을 Edge Layer(Nginx)로 위임했으므로:

```
FastAPI의 역할이 더욱 단순해짐:

Before (인증 포함):
├─ 인증 미들웨어
├─ 토큰 검증
├─ 비즈니스 로직
└─ 에러 처리

After (인증 위임):
├─ X-Client-ID 수신 (신뢰)
├─ 비즈니스 로직
└─ 에러 처리

→ FastAPI가 "순수한 API 로직"에만 집중
→ 보안 관심사 분리로 코드 간결화
```

---

## 4. 구현 가이드라인

> **Why/What 원칙**: 구체적인 코드 패턴은 설계 문서로 위임한다. 여기서는 원칙만 기술한다.

### 4.1 비동기 원칙

| 원칙 | 설명 |
|------|------|
| **모든 I/O는 async** | DB, 네트워크, 파일 I/O는 반드시 `async/await` 사용 |
| **동기 라이브러리 회피** | `requests` 대신 `httpx`, `psycopg2` 대신 `asyncpg` |
| **블로킹 호출 격리** | 불가피한 동기 호출은 `run_in_executor`로 별도 스레드 |

### 4.2 Pydantic 원칙

| 원칙 | 설명 |
|------|------|
| **dict 직접 사용 금지** | 모든 입출력은 Pydantic 모델 경유 |
| **명시적 타입 힌트** | `Any` 타입 지양, 구체적 타입 명시 |
| **검증 규칙 선언적** | `Field(...)`, `validator` 활용 |

### 4.3 의존성 스택

| 컴포넌트 | 라이브러리 | 역할 |
|----------|-----------|------|
| **ASGI 서버** | Uvicorn | 프로덕션 ASGI 서버 |
| **프레임워크** | FastAPI | 라우팅, DI, 문서화 |
| **검증** | Pydantic v2 | 스키마 검증, 직렬화 |
| **HTTP 클라이언트** | httpx | 비동기 HTTP 요청 |
| **SSE** | sse-starlette | Server-Sent Events |

(구체적인 버전, 설정, 프로젝트 구조는 설계 문서에서 정의)

---

## 5. 트레이드오프 및 제약

### 5.1 감수하는 단점

| 단점 | 영향 | 보완 전략 |
|------|------|----------|
| **비동기 학습 곡선** | 팀원들의 async/await 패턴 학습 필요 | 코드 리뷰, 템플릿 제공 |
| **동기 라이브러리 사용 불가** | 일부 레거시 라이브러리 호환 안 됨 | 대안 라이브러리 사용 또는 executor 격리 |
| **디버깅 복잡도** | 비동기 스택트레이스 이해 필요 | ADR-009 구조화 로깅 활용 |
| **상대적 신생** | Django/Flask 대비 역사 짧음 | 충분히 성숙, Starlette 기반으로 안정적 |

### 5.2 재검토 트리거

다음 상황 발생 시 이 결정을 재검토한다:

- [ ] FastAPI의 장기 지원/유지보수 중단
- [ ] 더 나은 ASGI 프레임워크 등장 및 성숙
- [ ] Pydantic 호환성 문제 발생
- [ ] AI 생태계 표준 변화

---

## 6. 결론

### 6.1 최종 결정 요약

| 결정 항목 | 결정 내용 | 핵심 논거 |
|----------|----------|----------|
| **프레임워크** | FastAPI | 아키텍처 요구사항(R1~R5) 모두 충족하는 유일한 대안 |
| **ASGI 서버** | Uvicorn | FastAPI 공식 권장, 성능 검증됨 |
| **검증 라이브러리** | Pydantic v2 | FastAPI 내장, 타입 안전성 |

### 6.2 핵심 메시지

> **"FastAPI 선택은 '유행'이 아니라 '필연'이다."**

이 결정은:
- ADR-003(Temporal)의 **비동기 I/O** 요구사항을 네이티브로 충족
- ADR-005(스트리밍)의 **SSE 효율성** 요구사항을 추가 스택 없이 충족
- ADR-002(파이프라인)의 **스키마 검증** 요구사항을 Pydantic으로 충족
- Flask/Django로는 **우회로 없이는 불가능**한 요구사항들

---

## 관련 문서 (Related)

**선행 결정:**
- [ADR-002: AI 백엔드 범위 및 아키텍처 스타일](./002_Defining_Scope_and_Architecture_Style_of_AI_Backend_Application.md) — Pipeline Manager 역할 정의
- [ADR-003: 추론 작업 실행 모델 (Temporal)](./003_Inference_Task_Execution_Model_and_State_Management_Strategy.md) — 비동기 Workflow, Non-blocking I/O 요구
- [ADR-005: 실시간 스트리밍 채널 전략](./005_Realtime_Streaming_Channel_Strategy.md) — SSE 스트리밍 요구
- [ADR-008: 시스템 클라이언트 인증](./008_System_Client_Authentication_and_Access_Control_Strategy.md) — Edge 인증으로 Backend 단순화

**관련 결정:**
- [ADR-009: 통합 관측성 및 분산 추적](./009_Unified_Observability_and_Distributed_Tracing_Strategy.md) — 구조화 로깅으로 비동기 디버깅 지원

**설계/운영 문서:**
- [03_development/01_setup.md](../03_development/01_setup.md) — FastAPI 프로젝트 구조, 의존성 설정
- [03_development/03_contributing.md](../03_development/03_contributing.md) — 비동기 코딩 가이드라인

---

## 변경 이력 (Changelog)

| 날짜 | 작성자 | 변경 내용 |
|------|--------|----------|
| 2024-12-28 | Senior Backend Engineer | 초안 작성 |
