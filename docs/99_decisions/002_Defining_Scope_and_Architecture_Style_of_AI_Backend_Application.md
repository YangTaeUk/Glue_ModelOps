# ADR-002: AI 백엔드 애플리케이션의 범위 및 아키텍처 스타일 정의

> **Status**: Accepted
> **Date**: 2024-12-27
> **Author**: System Architect
> **Context**: ADR-001(Edge Layer) 후속 결정 — 백엔드 애플리케이션 정체성 확립
> **Supersedes**: N/A

---

## TL;DR (한 줄 요약)

> 이 시스템은 **"Atomic AI Pipeline Manager"**이다. 개별 추론과 전/후처리를 단위 작업으로 관리하며, 선형 파이프라인만 지원한다. 복잡한 비즈니스 로직은 상위 계층에 위임한다.

---

## 1. 배경 및 문제 정의

### 1.1 배경 (Context)

ADR-001에서 Edge Abstraction Layer(Nginx)를 도입하여 외부 트래픽을 안전하게 처리하는 방법을 결정했다. 이제 그 뒷단에 위치할 **AI 백엔드 애플리케이션의 정체성과 범위**를 확정해야 한다.

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     시스템 계층 구조                                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   [External Clients]                                                     │
│          │                                                               │
│          ▼                                                               │
│   ┌─────────────────────────────────────────┐                           │
│   │  Edge Layer (Nginx) — ADR-001 결정 완료  │                           │
│   └─────────────────────────────────────────┘                           │
│          │                                                               │
│          ▼                                                               │
│   ┌─────────────────────────────────────────┐                           │
│   │  AI Backend Application — 본 ADR 대상    │  ◀── "이것이 무엇인가?"   │
│   └─────────────────────────────────────────┘                           │
│          │                                                               │
│          ▼                                                               │
│   ┌─────────────────────────────────────────┐                           │
│   │  Inference Engines (vLLM, Triton)        │                           │
│   └─────────────────────────────────────────┘                           │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 핵심 문제 (Core Issue)

**"이 시스템은 도대체 무엇인가?"**

시스템의 정체성이 불명확하면 다음 문제가 발생한다:

| 증상 | 결과 |
|------|------|
| 범위 무한 확장 | "이것도 되나요?" 요청에 계속 기능 추가 → 시스템 비대화 |
| 책임 혼란 | 비즈니스 로직이 어디서 처리되어야 하는지 모호 |
| 아키텍처 오염 | DB 조회, 조건 분기 등이 추론 파이프라인에 침투 |

### 1.3 결정이 필요한 이유

우리는 세 가지 핵심 질문에 답해야 한다:

| # | 질문 | 답변 필요성 |
|---|------|------------|
| 1 | **정체성**: 이 시스템은 무엇인가? | 팀원 간 공통 이해 확립 |
| 2 | **범위**: 어디까지 책임지고, 어디서 멈추는가? | 범위 무한 확장 방지 |
| 3 | **인터페이스**: 다양한 모델을 어떻게 수용하는가? | 확장성 확보 |

---

## 2. 결정 사항 (Decisions)

### 2.1 정체성: "Atomic AI Pipeline Manager"

#### 결정

> **이 시스템은 "Atomic AI Pipeline Manager"이다.**

- **단순한 모델 래퍼가 아니다**: 단순히 추론 엔진을 호출하고 결과를 반환하는 Thin Proxy가 아니다.
- **복잡한 비즈니스 애플리케이션이 아니다**: ERP, CRM처럼 도메인 로직을 내장하는 시스템이 아니다.
- **"단위 작업(Atomic Task)" 관리자이다**: 개별 모델의 추론(Inference)과 이를 보조하는 전/후처리 과정을 하나의 원자적 작업으로 관리한다.

#### 정체성 스펙트럼

```
┌─────────────────────────────────────────────────────────────────────────┐
│                       시스템 정체성 스펙트럼                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   Thin Proxy          Atomic Pipeline Manager         Business App      │
│   (모델 래퍼)               (우리 위치)               (도메인 로직)       │
│       │                         │                          │            │
│       ▼                         ▼                          ▼            │
│   ────●─────────────────────────●──────────────────────────●────────    │
│       │                         │                          │            │
│   단순 전달              전/후처리 + 연계            비즈니스 규칙        │
│   상태 없음              작업 단위 관리              복잡한 분기          │
│   재시도 없음            Temporal 오케스트레이션      DB/외부 시스템      │
│                                                                          │
│   ✗ 너무 단순            ✓ 우리가 제공하는 것        ✗ 범위 초과         │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

#### "Atomic Task"의 정의

하나의 Atomic Task는 다음으로 구성된다:

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     Atomic Task 구조                                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ┌───────────────┐    ┌───────────────┐    ┌───────────────┐          │
│   │ Pre-Process   │ ─▶ │   Inference   │ ─▶ │ Post-Process  │          │
│   │ (전처리)      │    │   (추론)      │    │ (후처리)      │          │
│   └───────────────┘    └───────────────┘    └───────────────┘          │
│                                                                          │
│   예시:                                                                  │
│   ┌───────────────┐    ┌───────────────┐    ┌───────────────┐          │
│   │ 토큰화        │ ─▶ │ LLM 추론      │ ─▶ │ 포맷 변환     │          │
│   │ 프롬프트 주입 │    │               │    │ 필터링        │          │
│   └───────────────┘    └───────────────┘    └───────────────┘          │
│                                                                          │
│   이 전체가 하나의 "원자적 단위"로 관리된다.                             │
│   성공하거나 실패하거나. 부분 실행은 없다.                               │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

### 2.2 범위: 선형 파이프라인으로 제한

#### 배경: 모델 연계의 필요성 인정

현대 AI 시스템에서 단일 모델만으로 완결되는 작업은 드물다. 트랜스포머 기반 모델의 특성상, 2~3개 모델의 연계(Chaining)가 필수적이다.

| 유형 | 예시 | 연계 모델 수 |
|------|------|-------------|
| RAG | Embedding → Retrieval → LLM | 2~3 |
| 멀티모달 | Vision → LLM → TTS | 3 |
| 정제 | LLM (초안) → LLM (검토) | 2 |

#### 결정

> **연계 기능은 제공하되, "선형적 파이프라인(Linear Pipeline)"으로 제한한다.**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                 허용되는 파이프라인 vs 허용되지 않는 파이프라인            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ✓ 허용: 선형 파이프라인 (Linear Pipeline)                             │
│   ─────────────────────────────────────────                              │
│                                                                          │
│   [Input] ──▶ [Model A] ──▶ [Model B] ──▶ [Model C] ──▶ [Output]        │
│                                                                          │
│   • 순차적 실행                                                          │
│   • 이전 단계 출력 → 다음 단계 입력                                      │
│   • 명확한 시작과 끝                                                     │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────────  │
│                                                                          │
│   ✗ 허용 안 됨: 분기/병합 파이프라인 (Branching Pipeline)                │
│   ─────────────────────────────────────────────────────                  │
│                                                                          │
│                    ┌──▶ [Model B] ──┐                                   │
│   [Input] ──▶ [A] ─┤                ├──▶ [D] ──▶ [Output]               │
│                    └──▶ [Model C] ──┘                                   │
│                             │                                            │
│                             ▼                                            │
│                      if (condition) {                                    │
│                        // 비즈니스 로직                                  │
│                      }                                                   │
│                                                                          │
│   • 조건 분기 ❌                                                         │
│   • 병렬 실행 후 병합 ❌                                                 │
│   • 외부 시스템 조회 후 분기 ❌                                          │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 범위 경계 (Boundary Definition)

| 우리가 하는 것 (In-Scope) | 우리가 하지 않는 것 (Out-of-Scope) |
|--------------------------|-----------------------------------|
| 모델 A → B → C 순차 실행 | 조건문 기반 분기 (if/else) |
| 전/후처리 핸들러 실행 | 외부 DB 조회 후 분기 결정 |
| 단계 간 데이터 전달 | 사용자 인터랙션 대기 |
| 실패 시 재시도 (Temporal) | 복잡한 비즈니스 규칙 처리 |
| 파이프라인 상태 추적 | A/B 테스트 로직 |

#### Addendum: 분기의 경계 — Content-based Routing 허용 범위

> **위험 식별**: "선형 파이프라인만 허용"이라는 원칙이 실제 운영에서 발생하는 합리적 요구사항과 충돌할 수 있다.

**문제 시나리오:**
```
"입력 텍스트가 1000토큰 이상이면 요약 모델을 먼저 거치고,
 아니면 바로 답변 생성 모델로 가라."
```

이는 매우 흔한 요구사항이나, 순수한 "조건 분기 금지" 원칙에 위배된다. 이를 지키려면 클라이언트가 토큰 수를 체크해서 다른 파이프라인을 호출해야 하는데, 이는 **클라이언트 로직이 비대해지는 부작용**을 낳는다.

**해결: 분기 유형의 명확한 구분**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   분기 유형 분류 (Branching Classification)              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  ✓ 허용: Content-based Routing (데이터 특성 기반 라우팅)         │   │
│   │  ─────────────────────────────────────────────────────────────   │   │
│   │                                                                   │   │
│   │  조건: 입력 데이터 자체의 특성만으로 판단                        │   │
│   │  ────                                                             │   │
│   │  • 토큰 수 (len(tokens) > 1000)                                  │   │
│   │  • 이미지 해상도 (width > 4096)                                  │   │
│   │  • 오디오 길이 (duration > 60s)                                  │   │
│   │  • 언어 감지 (detected_lang == "ko")                             │   │
│   │                                                                   │   │
│   │  특징:                                                           │   │
│   │  • 순수 함수 (Pure Function): 동일 입력 → 동일 결과              │   │
│   │  • 외부 의존성 없음: DB, API, 세션 조회 불필요                   │   │
│   │  • 테스트 용이: mock 없이 단위 테스트 가능                       │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  ✗ 금지: Business-based Branching (비즈니스 규칙 기반 분기)      │   │
│   │  ─────────────────────────────────────────────────────────────   │   │
│   │                                                                   │   │
│   │  조건: 외부 시스템 조회 또는 비즈니스 규칙 필요                   │   │
│   │  ────                                                             │   │
│   │  • 사용자 등급 (user.tier == "premium")                          │   │
│   │  • 결제 상태 (payment.status == "completed")                     │   │
│   │  • 재고 확인 (inventory.count > 0)                               │   │
│   │  • A/B 테스트 그룹 (experiment.group == "A")                     │   │
│   │                                                                   │   │
│   │  특징:                                                           │   │
│   │  • Side Effect 필수: 외부 시스템 조회 필요                       │   │
│   │  • 상태 의존적: 동일 입력이라도 결과가 달라질 수 있음            │   │
│   │  • 테스트 복잡: mock/stub 필수                                   │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

**설계 원칙: Smart Handler Pattern**

Content-based Routing은 **핸들러 내부 구현으로 캡슐화**한다. 파이프라인 정의는 여전히 선형으로 유지되며, 라우팅 로직은 핸들러 내부에 숨긴다.

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Smart Handler Pattern                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   외부 관점 (파이프라인 정의):                                           │
│   ───────────────────────────                                            │
│   [Input] ──▶ [SmartHandler] ──▶ [Model] ──▶ [Output]                   │
│                                                                          │
│   내부 관점 (핸들러 구현):                                               │
│   ────────────────────────                                               │
│   SmartHandler는 입력 데이터 특성에 따라 내부적으로 최적 경로 선택       │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────      │
│                                                                          │
│   설계 원칙:                                                             │
│   ──────────                                                             │
│                                                                          │
│   1. 토폴로지 불변 (Topology Invariance)                                 │
│      • 파이프라인 그래프는 항상 선형으로 유지                            │
│      • 분기는 핸들러 "내부"에서만 발생                                   │
│                                                                          │
│   2. 캡슐화 (Encapsulation)                                              │
│      • 라우팅 로직은 핸들러의 구현 세부사항                              │
│      • 파이프라인 정의자는 라우팅 존재를 알 필요 없음                    │
│                                                                          │
│   3. 순수 함수 제약 (Pure Function Constraint)                           │
│      • 라우팅 판단은 입력 데이터만으로 결정                              │
│      • 외부 상태나 시스템 조회 금지                                      │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

**허용 범위 요약:**

| 분기 유형 | 허용 여부 | 구현 위치 | 예시 |
|----------|----------|----------|------|
| **Content-based** | ✓ 허용 | Handler 내부 | 토큰 수, 이미지 크기, 언어 감지 |
| **Business-based** | ✗ 금지 | 상위 계층 | VIP 등급, 결제 상태, A/B 테스트 |

> **원칙 보완**: "조건 분기 금지"는 "비즈니스 로직에 의한 분기 금지"로 명확화한다. 데이터 특성에 따른 최적화는 핸들러의 내부 구현으로 허용한다.

---

#### 제한 이유: Bloat 방지

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    범위 제한의 이유                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   "모든 것을 할 수 있는 시스템은 아무것도 잘 하지 못한다."                │
│                                                                          │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  비즈니스 로직을 포함하면...                                     │   │
│   │                                                                   │   │
│   │  1. 테스트 복잡도 폭증                                           │   │
│   │     └─▶ 추론 테스트 + 비즈니스 로직 테스트 혼재                  │   │
│   │                                                                   │   │
│   │  2. 배포 결합도 증가                                             │   │
│   │     └─▶ 비즈니스 규칙 변경 시 AI 시스템 재배포 필요              │   │
│   │                                                                   │   │
│   │  3. 책임 모호                                                    │   │
│   │     └─▶ 버그 발생 시 "AI 문제인가, 비즈니스 로직 문제인가?"      │   │
│   │                                                                   │   │
│   │  4. 확장성 저하                                                  │   │
│   │     └─▶ 도메인별 분기가 누적되어 스파게티 코드화                 │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
│   결론: 복잡한 비즈니스 로직은 상위 애플리케이션 계층에 위임한다.        │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 책임 분리 다이어그램

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      계층별 책임 분리                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  상위 애플리케이션 계층 (Client / BFF / Orchestrator)            │   │
│   │  ─────────────────────────────────────────────────────────────   │   │
│   │  • 비즈니스 규칙 (할인 정책, 권한 검증)                          │   │
│   │  • 조건 분기 ("VIP면 이 모델, 일반이면 저 모델")                 │   │
│   │  • 외부 시스템 연동 (DB, CRM, 결제)                              │   │
│   │  • 사용자 세션/컨텍스트 관리                                     │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                    │                                     │
│                                    ▼                                     │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  AI Backend Application (본 시스템)                              │   │
│   │  ─────────────────────────────────────────────────────────────   │   │
│   │  • 선형 파이프라인 실행                                          │   │
│   │  • 전/후처리 핸들러 관리                                         │   │
│   │  • 작업 상태 추적 및 재시도                                      │   │
│   │  • 추론 엔진 호출                                                │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                    │                                     │
│                                    ▼                                     │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  Inference Engines (vLLM, Triton)                                │   │
│   │  ─────────────────────────────────────────────────────────────   │   │
│   │  • 모델 로딩 및 GPU 관리                                         │   │
│   │  • 배치 처리 최적화                                              │   │
│   │  • 추론 연산                                                     │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

### 2.3 인터페이스 전략: Protocol-Agnostic Pipeline Templating

#### 배경: 데이터 표준화의 한계

AI 모델의 입출력은 본질적으로 다양하다:

| 모델 유형 | 입력 | 출력 | 선호 프로토콜 |
|----------|------|------|--------------|
| LLM (Text) | JSON/Text | Streaming Text | SSE, WebSocket |
| Vision | Binary Image | JSON | HTTP |
| TTS | Text | Audio Stream | WebSocket |
| ASR | Audio Stream | Text | WebSocket |
| Embedding | Text | Float Vector | HTTP |

**"모든 모델의 입출력을 단일 포맷으로 강제하는 것은 불가능하며, 시도해서도 안 된다."**

#### 결정

> **입출력 데이터 자체를 표준화하지 않고, "데이터가 흐르는 파이프라인 구조"를 템플릿화한다.**

```
┌─────────────────────────────────────────────────────────────────────────┐
│              Protocol-Agnostic Pipeline Templating                       │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ┌───────────────────────────────────────────────────────────────┐     │
│   │                    Pipeline Template                           │     │
│   │   ─────────────────────────────────────────────────────────   │     │
│   │                                                                 │     │
│   │   ┌─────────┐      ┌─────────┐      ┌─────────┐               │     │
│   │   │ Input   │ ──▶  │  Stage  │ ──▶  │ Output  │               │     │
│   │   │ Handler │      │   N     │      │ Handler │               │     │
│   │   └─────────┘      └─────────┘      └─────────┘               │     │
│   │       ▲                                   ▲                    │     │
│   │       │                                   │                    │     │
│   │       └───────────── Pluggable ───────────┘                    │     │
│   │                                                                 │     │
│   └───────────────────────────────────────────────────────────────┘     │
│                                                                          │
│   표준화되는 것:                                                         │
│   ─────────────                                                          │
│   • 파이프라인 정의 스키마 (YAML/JSON)                                   │
│   • 핸들러 인터페이스 (Input/Output Handler Protocol)                    │
│   • 스테이지 간 데이터 전달 규약                                         │
│   • 상태 추적 및 에러 처리 방식                                          │
│                                                                          │
│   표준화되지 않는 것:                                                    │
│   ─────────────────                                                      │
│   • 실제 페이로드 포맷 (Text, Binary, Stream)                            │
│   • 통신 프로토콜 (HTTP, WebSocket, gRPC)                                │
│   • 모델별 파라미터 (temperature, max_tokens 등)                         │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 플러그인 핸들러 구조

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Handler Plugin Architecture                           │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  Handler Interface (공통 계약)                                   │   │
│   │  ─────────────────────────────                                   │   │
│   │  모든 핸들러가 준수해야 하는 계약:                               │   │
│   │  • 데이터 처리 (Process): 입력 → 출력 변환                       │   │
│   │  • 유효성 검증 (Validate): 처리 가능 여부 판단                   │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                              ▲                                           │
│                              │ implements                                │
│          ┌───────────────────┼───────────────────┐                      │
│          │                   │                   │                      │
│   ┌──────┴──────┐     ┌──────┴──────┐     ┌──────┴──────┐              │
│   │ Text        │     │ Image       │     │ Audio       │              │
│   │ Handler     │     │ Handler     │     │ Handler     │              │
│   └─────────────┘     └─────────────┘     └─────────────┘              │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────      │
│                                                                          │
│   설계 원칙:                                                             │
│   ──────────                                                             │
│                                                                          │
│   1. 단일 계약 (Single Contract)                                         │
│      • 모든 핸들러는 동일한 인터페이스를 구현                            │
│      • 파이프라인 코어는 구체 타입을 알지 못함                           │
│                                                                          │
│   2. 확장 개방 / 수정 폐쇄 (OCP)                                         │
│      • 새 모델 = 새 핸들러 구현                                          │
│      • 기존 코드 수정 없음                                               │
│                                                                          │
│   3. 등록 기반 발견 (Registration-based Discovery)                       │
│      • 핸들러는 레지스트리에 등록                                        │
│      • 런타임에 적절한 핸들러 선택                                       │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 파이프라인 템플릿 설계 원칙

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Pipeline Template Design Principles                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   파이프라인 템플릿이 정의해야 하는 것:                                  │
│   ─────────────────────────────────────                                  │
│                                                                          │
│   1. 스테이지 순서 (Stage Sequence)                                      │
│      • 선형 실행 순서 명시                                               │
│      • 각 스테이지의 역할 정의                                           │
│                                                                          │
│   2. 핸들러 바인딩 (Handler Binding)                                     │
│      • 각 스테이지에 사용할 입/출력 핸들러 지정                          │
│      • 런타임에 핸들러 인스턴스 주입                                     │
│                                                                          │
│   3. 프로토콜 힌트 (Protocol Hint)                                       │
│      • 스트리밍 여부, 통신 방식 힌트                                     │
│      • Connector가 최종 프로토콜 결정                                    │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────      │
│                                                                          │
│   파이프라인 템플릿이 정의하지 않는 것:                                  │
│   ───────────────────────────────────────                                │
│                                                                          │
│   • 모델 서버 URL (런타임 설정에 위임)                                   │
│   • 인증 정보 (외부 설정에 위임)                                         │
│   • 구체적인 파라미터 값 (정책으로 관리)                                 │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

#### Addendum: Context Propagation — 스테이지 간 메타데이터 전달

> **위험 식별**: 문서상 데이터 흐름이 "이전 단계 출력 → 다음 단계 입력" 구조로만 기술되어 있어, 메타데이터를 함께 전달하는 메커니즘이 누락되어 있다.

**문제 시나리오:**
```
Stage 1(전처리)에서 생성된 메타데이터(원본 텍스트 길이, 언어 감지 결과)가
Stage 3(후처리)에서 필요하다면?

[전처리] ─output→ [추론] ─output→ [후처리]
    │                                   │
    └── detected_lang: "ko" ────────────┘  ← 어떻게 전달?
```

Stage 2(추론)의 출력에는 언어 정보가 없다. 메타데이터가 중간 단계에서 소실된다.

**해결: Pipeline Context 객체 (Envelope Pattern)**

파이프라인을 흐르는 데이터는 **단순 Raw Data가 아니라, Payload + Metadata를 포함하는 Context 객체**이다.

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Pipeline Context 구조 (Envelope Pattern)              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  PipelineContext                                                 │   │
│   │  ─────────────────                                               │   │
│   │                                                                   │   │
│   │  ┌─────────────────────────────────────────────────────────┐    │   │
│   │  │  payload: Any                                            │    │   │
│   │  │  ─────────────                                           │    │   │
│   │  │  현재 스테이지의 실제 데이터 (텍스트, 이미지, 벡터 등)   │    │   │
│   │  │  • 각 스테이지가 변환하는 대상                           │    │   │
│   │  │  • 다음 스테이지의 입력이 됨                             │    │   │
│   │  └─────────────────────────────────────────────────────────┘    │   │
│   │                                                                   │   │
│   │  ┌─────────────────────────────────────────────────────────┐    │   │
│   │  │  metadata: Dict[str, Any]                                │    │   │
│   │  │  ─────────────────────────                               │    │   │
│   │  │  스테이지를 거치며 누적되는 메타데이터                   │    │   │
│   │  │  • 각 스테이지가 추가할 수 있음 (Append-only 권장)       │    │   │
│   │  │  • 후속 스테이지에서 읽을 수 있음                        │    │   │
│   │  │  • 삭제/수정은 제한 (감사 추적 목적)                     │    │   │
│   │  └─────────────────────────────────────────────────────────┘    │   │
│   │                                                                   │   │
│   │  ┌─────────────────────────────────────────────────────────┐    │   │
│   │  │  trace: 추적 정보                                        │    │   │
│   │  │  ────────────────                                        │    │   │
│   │  │  요청 추적 정보 (불변)                                   │    │   │
│   │  │  • 요청 식별자                                           │    │   │
│   │  │  • 파이프라인 식별자                                     │    │   │
│   │  │  • 시작 시각                                             │    │   │
│   │  │  • 스테이지 이력                                         │    │   │
│   │  │  (구체적인 필드 정의는 설계 문서에서 결정)               │    │   │
│   │  └─────────────────────────────────────────────────────────┘    │   │
│   │                                                                   │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

**Context 흐름 다이어그램:**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Context Propagation Flow                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   [Request] ──▶ [Stage 1] ──▶ [Stage 2] ──▶ [Stage N] ──▶ [Response]   │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────      │
│                                                                          │
│   각 스테이지에서 Context가 어떻게 변화하는가:                           │
│                                                                          │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  Context 진입 시                    Context 반환 시             │   │
│   │  ───────────────                    ───────────────             │   │
│   │  payload: [현재 데이터]      →      payload: [변환된 데이터]    │   │
│   │  metadata: [누적된 정보]     →      metadata: [정보 추가됨]     │   │
│   │  trace: [추적 정보]          →      trace: [불변]               │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
│   메타데이터 활용 예:                                                    │
│   ──────────────────                                                     │
│   • Stage 1에서 감지한 언어 정보를 Stage 3에서 포맷팅에 활용             │
│   • Stage 2에서 기록한 지연 시간을 모니터링에 활용                       │
│   • 모든 스테이지 기록이 최종 응답과 함께 반환                           │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

**핸들러 계약 원칙 (Handler Contract Principles):**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Handler Contract Principles                           │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   1. Context-in, Context-out                                             │
│      • 핸들러는 Context를 받아 변환된 Context를 반환                     │
│      • 입력 Context를 직접 수정하지 않음 (Immutability 권장)             │
│                                                                          │
│   2. Payload 변환 책임                                                   │
│      • 핸들러는 payload를 변환하여 다음 스테이지에 전달                  │
│      • 변환 실패 시 명확한 에러 반환                                     │
│                                                                          │
│   3. Metadata 추가 권한                                                  │
│      • 핸들러는 metadata에 정보를 추가할 수 있음                         │
│      • 기존 metadata 수정/삭제는 제한 (Append-only 권장)                 │
│                                                                          │
│   4. Trace 읽기 전용                                                     │
│      • trace는 시스템이 관리하며 핸들러는 읽기만 가능                    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

**메타데이터 네임스페이스 원칙:**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Metadata Namespace Principles                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   충돌 방지 전략:                                                        │
│   ───────────────                                                        │
│   • 스테이지별 네임스페이스 prefix 사용                                  │
│   • 형식: "{stage_name}.{key_name}"                                      │
│                                                                          │
│   예약된 네임스페이스:                                                   │
│   ─────────────────                                                      │
│   • "system.*" — 시스템 관리 메타데이터 (읽기 전용)                      │
│   • "trace.*" — 추적 정보 (읽기 전용)                                    │
│   • "user.*" — 클라이언트가 전달한 메타데이터                            │
│                                                                          │
│   설계 원칙:                                                             │
│   ──────────                                                             │
│   • 네임스페이스는 구현 시점에 구체화                                    │
│   • 핵심은 "충돌 방지"와 "출처 추적 가능성"                              │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

**핵심 원칙:**

| 원칙 | 설명 |
|------|------|
| **Payload는 변환** | 각 스테이지가 payload를 변환하여 다음 스테이지에 전달 |
| **Metadata는 누적** | 각 스테이지가 metadata에 추가 (Append-only 권장) |
| **Trace는 불변** | 시스템이 관리하며 핸들러는 읽기만 가능 |
| **네임스페이스 사용** | 스테이지별 prefix로 충돌 방지 |

---

## 3. 회피하는 안티 패턴

### 3.1 안티 패턴 #1: "Swiss Army Knife" 시스템

```
┌─────────────────────────────────────────────────────────────────────────┐
│   ❌ Swiss Army Knife 안티 패턴                                          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   "이것도 되고, 저것도 되고, 모든 것이 가능한 만능 시스템"                │
│                                                                          │
│   증상:                                                                  │
│   • "이 기능도 추가해 주세요" 요청에 계속 Yes                            │
│   • 코드베이스에 if/else 분기가 기하급수적으로 증가                      │
│   • 새 기능 추가 시 기존 기능이 깨짐                                     │
│   • 아무도 전체 시스템을 이해하지 못함                                   │
│                                                                          │
│   우리의 대응:                                                           │
│   ─────────────                                                          │
│   • 명확한 범위 경계 설정 (선형 파이프라인만)                            │
│   • Out-of-Scope 요청은 상위 계층으로 위임                               │
│   • "우리가 하지 않는 것" 목록 명시적 관리                               │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.2 안티 패턴 #2: "Leaky Abstraction" 파이프라인

```
┌─────────────────────────────────────────────────────────────────────────┐
│   ❌ Leaky Abstraction 안티 패턴                                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   "모델별 특수 로직이 파이프라인 전체에 침투"                            │
│                                                                          │
│   예시:                                                                  │
│   if model == "gpt-4":                                                   │
│       # GPT-4 전용 처리                                                  │
│   elif model == "llama":                                                 │
│       # Llama 전용 처리                                                  │
│   elif model == "whisper":                                               │
│       # Whisper 전용 처리                                                │
│   # ... 모델이 추가될 때마다 분기 증가                                   │
│                                                                          │
│   우리의 대응:                                                           │
│   ─────────────                                                          │
│   • 모델별 차이는 Handler 플러그인 내부에 캡슐화                         │
│   • 파이프라인 코어는 Handler 인터페이스만 알면 됨                       │
│   • 새 모델 추가 = 새 Handler 등록 (기존 코드 수정 없음)                 │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.3 안티 패턴 #3: "Premature Standardization"

```
┌─────────────────────────────────────────────────────────────────────────┐
│   ❌ Premature Standardization 안티 패턴                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   "모든 입출력을 하나의 표준 포맷으로 강제 변환"                         │
│                                                                          │
│   예시:                                                                  │
│   {                                                                      │
│     "universal_format": {                                                │
│       "type": "any",                                                     │
│       "data": "base64_encoded_everything",                               │
│       "metadata": { ... }                                                │
│     }                                                                    │
│   }                                                                      │
│                                                                          │
│   문제점:                                                                │
│   • 모든 데이터에 인코딩/디코딩 오버헤드 발생                            │
│   • 스트리밍 데이터 처리 불가                                            │
│   • 디버깅 시 원본 데이터 확인 어려움                                    │
│   • 새 데이터 타입마다 "표준"을 업데이트해야 함                          │
│                                                                          │
│   우리의 대응:                                                           │
│   ─────────────                                                          │
│   • 데이터 표준화 대신 파이프라인 구조 표준화                            │
│   • 각 모델의 네이티브 포맷 존중                                         │
│   • Handler가 변환 책임을 가짐 (필요한 경우에만)                         │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.4 안티 패턴 #4: "Hidden Business Logic"

```
┌─────────────────────────────────────────────────────────────────────────┐
│   ❌ Hidden Business Logic 안티 패턴                                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   "AI 파이프라인 내부에 비즈니스 규칙이 은밀하게 침투"                   │
│                                                                          │
│   예시:                                                                  │
│   def process_inference(request):                                        │
│       user = get_user(request.user_id)  # ← DB 조회                     │
│       if user.tier == "premium":         # ← 비즈니스 규칙               │
│           model = "gpt-4-turbo"                                          │
│       else:                                                              │
│           model = "gpt-3.5"                                              │
│       # ...                                                              │
│                                                                          │
│   문제점:                                                                │
│   • 비즈니스 규칙 변경 시 AI 시스템 배포 필요                            │
│   • AI 팀이 비즈니스 로직까지 관리해야 함                                │
│   • 단위 테스트에 DB mock이 필요해짐                                     │
│                                                                          │
│   우리의 대응:                                                           │
│   ─────────────                                                          │
│   • 모델 선택, 파라미터 결정은 호출자(Client)의 책임                     │
│   • 파이프라인은 전달받은 설정대로 실행만 함                             │
│   • "어떤 모델을 쓸지"는 이미 결정된 상태로 요청이 들어옴                │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 4. 결론

### 4.1 최종 결정 요약

| 결정 항목 | 결정 내용 |
|----------|----------|
| **정체성** | Atomic AI Pipeline Manager — 단위 작업 관리자 |
| **범위** | 선형 파이프라인만 지원, 복잡한 분기는 Out-of-Scope |
| **인터페이스** | Protocol-Agnostic Pipeline Templating |

### 4.2 경계 선언 (Boundary Statement)

**우리는 다음을 한다:**
- 개별 추론 작업의 전/후처리 관리
- 2~3개 모델의 선형 연계 실행
- 플러그인 핸들러를 통한 다양한 모델 지원
- Temporal을 통한 작업 상태 추적 및 재시도
- **Content-based Routing**: 입력 데이터 특성에 따른 최적화 (핸들러 내부 구현)

**우리는 다음을 하지 않는다:**
- **Business-based Branching**: 외부 시스템 조회 후 분기 결정
- 사용자 세션/컨텍스트 관리
- 비즈니스 규칙 처리 (가격, 권한, 할인 등)
- A/B 테스트 라우팅

**분기의 경계 (명확화):**

| 분기 유형 | 허용 | 구현 위치 | 판단 기준 |
|----------|------|----------|----------|
| Content-based | ✓ | Handler 내부 | 순수 함수로 표현 가능 (외부 의존성 없음) |
| Business-based | ✗ | 상위 계층 | 외부 시스템 조회 또는 비즈니스 규칙 필요 |

### 4.3 재검토 트리거 (Revisit Triggers)

다음 상황 발생 시 이 결정을 재검토한다:

- [ ] 선형 파이프라인으로 해결 불가능한 핵심 비즈니스 요구사항 발생
- [ ] 상위 계층에서 분기 로직 중복 구현이 심각해질 경우
- [ ] 새로운 AI 패러다임(Agent, Multi-Agent 등)의 표준화

---

## 관련 문서 (Related)

- [ADR-001: AI 서비스 엔드포인트를 외부에 안전하게 노출하는 방법](./001_How_to_Securely_Expose_AI_API_Endpoint_[Nginx%20OSS].md)
- [01_overview/01_strategy.md](../01_overview/01_strategy.md) - 프로젝트 전략
- [02_architecture/04_worker.md](../02_architecture/04_worker.md) - Temporal Worker 설계

---

## 변경 이력 (Changelog)

| 날짜 | 작성자 | 변경 내용 |
|------|--------|----------|
| 2024-12-27 | System Architect | 초안 작성 — 시스템 정체성 및 범위 확정 |
| 2024-12-27 | System Architect | Addendum 추가 — Content-based Routing 허용 범위 명확화, Smart Handler Pattern 도입 |
| 2024-12-27 | System Architect | Addendum 추가 — Context Propagation (Envelope Pattern), Pipeline Context 객체 정의 |
| 2024-12-27 | System Architect | Diet 리팩토링 — 코드 예시 제거, 설계 원칙(Design Principles)으로 대체 |
| 2024-12-27 | System Architect | Why/What 원칙 준수 — trace 필드 타입을 역할 설명으로 대체 |
