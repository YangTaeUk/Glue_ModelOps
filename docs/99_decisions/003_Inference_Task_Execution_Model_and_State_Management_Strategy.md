# ADR-003: 추론 작업 실행 모델 및 상태 관리 전략

> **Status**: Accepted
> **Date**: 2024-12-27
> **Author**: System Architect
> **Context**: ADR-002(Pipeline Manager) 후속 결정 — 파이프라인 실행 메커니즘 구체화
> **Supersedes**: N/A

---

## TL;DR (한 줄 요약)

> AI 추론은 "긴 실행 시간"과 "빈번한 일시 장애"라는 본질적 특성 때문에 동기 HTTP 모델로 처리할 수 없다. **Durable Execution 패턴**을 적용하여 파이프라인의 내구성을 확보하고, 개발자가 상태 관리 코드를 직접 작성하지 않게 한다.

---

## 1. 문제 정의: 왜 동기 방식은 실패하는가

### 1.1 AI 추론의 본질적 특성

AI 추론은 전통적인 웹 요청과 **근본적으로 다른 특성**을 가진다:

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   전통적 웹 요청 vs AI 추론 요청                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│                    전통적 웹 요청              AI 추론 요청              │
│                    ─────────────              ───────────               │
│   실행 시간        밀리초 단위                 분 단위                   │
│   실패 유형        결정적 (Deterministic)      확률적 (Stochastic)       │
│   상태             무상태 (Stateless)          다단계 상태 존재          │
│   리소스           CPU (탄력적)                GPU (경직적)              │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

이 차이가 왜 중요한가:

| 특성 | 동기 HTTP에서의 문제 |
|------|---------------------|
| **긴 실행 시간** | HTTP 커넥션 타임아웃 초과, 게이트웨이/로드밸런서 표준 설정과 충돌 |
| **일시 장애 빈번** | GPU OOM, Cold Start — 재시도 시 전체 작업 재실행 필요 |
| **다단계 파이프라인** | 어디까지 성공했는지 알 수 없음, 부분 복구 불가능 |

### 1.2 동기 모델의 구조적 한계

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   동기 모델이 실패하는 시나리오                          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   [시나리오 1: 타임아웃]                                                 │
│   ─────────────────────                                                  │
│   Client ──▶ Gateway ──▶ Server ──▶ GPU (추론 진행 중...)               │
│                 │                                                        │
│                 └── 60초 후 "Gateway Timeout" ──▶ 클라이언트 에러        │
│                                               └── GPU는 계속 실행 중     │
│                                               └── 결과는 어디로?         │
│                                                                          │
│   [시나리오 2: 장애 전파]                                                │
│   ─────────────────────                                                  │
│   GPU OOM 발생 ──▶ 요청 실패 ──▶ 클라이언트 즉시 재시도                 │
│                              ──▶ 다른 클라이언트도 재시도                │
│                              ──▶ 시스템 전체 과부하 (Thundering Herd)    │
│                                                                          │
│   [시나리오 3: 작업 손실]                                                │
│   ─────────────────────                                                  │
│   [Pre ✓] ──▶ [Model A ✓] ──▶ [Model B] ──✗ (서버 재시작)              │
│                                          └── 어디까지 완료? → 모름      │
│                                          └── 처음부터 재실행 필요       │
│                                          └── GPU 비용 중복 발생         │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

**핵심 통찰:**
> 동기 HTTP 모델은 **"요청 = 커넥션 = 작업"**이라는 강한 결합을 전제한다. AI 추론처럼 작업 시간이 길고 실패가 빈번한 도메인에서는 이 결합이 **시스템 취약점**이 된다.

---

## 2. 전략적 결정: 세 가지 핵심 선택

### 2.1 결정 #1: 비동기 워크플로우 실행 모델

> **"요청 즉시 작업 ID를 발급하고, 실제 작업은 백그라운드에서 수행한다."**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   실행 모델: Async Workflow over Sync Request            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   동기 모델 (기각)                 비동기 모델 (채택)                    │
│   ─────────────────               ──────────────────                    │
│                                                                          │
│   [요청] ─────────────▶ [응답]     [요청] ──▶ [Job ID 발급]             │
│          (5분 대기)                         (즉시, 밀리초)               │
│                                                   │                      │
│                                                   ▼                      │
│                                            [백그라운드 실행]             │
│                                                   │                      │
│                                                   ▼                      │
│                                            [결과 스트리밍]               │
│                                                                          │
│   장점:                                                                  │
│   • 커넥션 점유 시간: 분 단위 → 밀리초 단위                              │
│   • 클라이언트 타임아웃: 발생 불가 (즉시 응답)                           │
│   • 재시도 시: 동일 Job ID로 상태 조회 가능                              │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

**인터페이스 원칙:**
- **Job ID 기반 리소스 식별**: 모든 추론 요청은 고유 식별자를 통해 추적
- **HTTP 202 Accepted 패턴**: 요청 수신 확인과 작업 완료를 분리
- **상태 조회 엔드포인트 제공**: 작업 진행 상황을 언제든 확인 가능

---

### 2.2 결정 #2: Workflow Engine 도입 (Temporal)

> **"상태 관리의 책임을 애플리케이션 코드에서 전문 엔진으로 위임한다."**

#### 왜 단순 Message Queue로는 부족한가

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   Message Queue vs Workflow Engine                       │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   "단순 큐(Queue)는 파이프라인의 의미론(Semantics)을 모른다"             │
│                                                                          │
│   ┌───────────────────────────────────────────────────────────────┐     │
│   │  ADR-002에서 정의한 파이프라인:                                │     │
│   │                                                                 │     │
│   │  [Pre] ──▶ [Model A] ──▶ [Model B] ──▶ [Post]                  │     │
│   │    │           │             │           │                      │     │
│   │    └─────── Context Propagation ─────────┘                      │     │
│   └───────────────────────────────────────────────────────────────┘     │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────      │
│                                                                          │
│   Message Queue가 아는 것:          Workflow Engine이 아는 것:          │
│   ─────────────────────────          ─────────────────────────          │
│   • Task A 완료                      • Task A는 Pipeline X의 1단계       │
│   • Task B 실행 중                   • Task B 실패 시 → Task A 결과 보존 │
│   • Task C 대기 중                   • 전체 진행률: 66%                  │
│                                      • Context 자동 전파                 │
│                                                                          │
│   결론: Message Queue 사용 시 파이프라인 상태 관리 코드를 직접 구현해야  │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

#### Temporal 선택 논거: 복잡도 아웃소싱

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   Temporal 도입 = 복잡도 감소                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   핵심 통찰:                                                             │
│   ──────────                                                             │
│   Temporal은 "추가 복잡도"가 아니다.                                     │
│   원래 우리가 직접 구현해야 할 것들을 엔진에 위임하는 "복잡도 이전"이다. │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────      │
│                                                                          │
│   Temporal 없이 우리가 구현해야 할 것:                                   │
│   ─────────────────────────────────────                                  │
│   □ 파이프라인 상태 DB 스키마 설계                                       │
│   □ 각 단계 완료 시 상태 업데이트 트랜잭션                               │
│   □ 실패 시 어느 단계까지 성공했는지 조회 로직                           │
│   □ 재시도 전략 (지수 백오프, 최대 횟수, 비재시도 에러 분류)             │
│   □ 타임아웃 처리 (단계별, 전체)                                         │
│   □ 중간 결과 저장소 선정 및 관리                                        │
│   □ 워커 장애 시 작업 재할당 스케줄러                                    │
│   □ Dead Letter 처리 및 알림                                             │
│   □ 진행률 조회 API                                                      │
│   □ 작업 취소 기능                                                       │
│                                                                          │
│   Temporal 도입 시 자동으로 제공됨:                                      │
│   ────────────────────────────────                                       │
│   ✓ 워크플로우 상태 자동 저장 (Event Sourcing 기반)                      │
│   ✓ Activity 단위 재시도 정책 (선언적 설정)                              │
│   ✓ 다층 타임아웃 체계 (대기/실행/종단간)                                │
│   ✓ Durable Execution — 실패 지점부터 자동 재개                          │
│   ✓ Query API — 실행 중 상태 조회                                        │
│   ✓ Signal/Cancel — 외부에서 워크플로우 제어                             │
│   ✓ 전체 실행 히스토리 (디버깅, 감사)                                    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

#### Temporal 핵심 개념 매핑

| Temporal 개념 | 우리 시스템에서의 의미 | 가치 |
|--------------|----------------------|------|
| **Workflow** | 하나의 AI 파이프라인 실행 | 전체 작업의 원자성 보장 |
| **Activity** | 개별 스테이지 (Pre, Inference, Post) | 실패 단위 격리, 독립 재시도 |
| **Task Queue** | 모델별/리소스별 큐 분리 | GPU/CPU 워커 분리 가능 |
| **Worker** | 파이프라인 실행 프로세스 | 수평 확장, 장애 격리 |

---

### 2.3 결정 #3: SSE 기반 결과 스트리밍

> **"클라이언트가 상태를 물어보게 하지 말고, 서버가 상태를 밀어준다."**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   통신 패턴: Push over Pull                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   Polling (기각)                       SSE Push (채택)                   │
│   ─────────────                        ────────────                      │
│                                                                          │
│   Client: "완료됐나요?"                Server: "시작했습니다"             │
│   Server: "아니요"                     Server: "1단계 완료"              │
│   Client: (1초 대기)                   Server: "토큰: The"               │
│   Client: "완료됐나요?"                Server: "토큰: answer"            │
│   Server: "아니요"                     Server: "완료되었습니다"          │
│   ... (수백 회 반복)                                                     │
│                                                                          │
│   문제점:                              장점:                             │
│   • 불필요한 트래픽                    • 변화 시에만 전송                │
│   • 서버 부하                          • 실시간 UX                       │
│   • 실시간성 저하                      • 단일 커넥션                     │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

**SSE 선택 이유:**
- **단방향 푸시 충분**: 클라이언트 → 서버 실시간 통신 불필요
- **HTTP 인프라 호환**: 기존 로드밸런서, 프록시 그대로 사용
- **자동 재연결**: 브라우저 내장 EventSource API 지원
- **WebSocket 대비 단순**: 양방향 필요 없는 상황에서 오버스펙 회피

---

## 3. 아키텍처 개요

### 3.1 시스템 계층 구조

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     시스템 계층 및 책임 분리                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  클라이언트 계층                                                 │   │
│   │  ─────────────────                                               │   │
│   │  • 요청 발송 → Job ID 수신                                       │   │
│   │  • SSE 구독 → 실시간 결과 수신                                   │   │
│   │  • 재연결 시 Last Event ID 기반 복구                             │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                    │                                     │
│                                    ▼                                     │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  Edge Layer (ADR-001)                                            │   │
│   │  ────────────────────                                            │   │
│   │  • 인증/인가, Rate Limiting                                      │   │
│   │  • SSL Termination                                               │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                    │                                     │
│                                    ▼                                     │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  API Gateway                                                     │   │
│   │  ───────────                                                     │   │
│   │  • 요청 검증 및 Workflow 시작                                    │   │
│   │  • Job ID 발급 및 HTTP 202 응답                                  │   │
│   │  • SSE 스트리밍 엔드포인트                                       │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                    │                                     │
│                                    ▼                                     │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  Workflow Engine (Temporal)                                      │   │
│   │  ──────────────────────────                                      │   │
│   │  • 워크플로우 상태 영속화 (Durable Execution)                    │   │
│   │  • Activity 스케줄링 및 재시도 관리                              │   │
│   │  • Task Queue 기반 워커 분배                                     │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                    │                                     │
│                                    ▼                                     │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  Workers                                                         │   │
│   │  ───────                                                         │   │
│   │  • CPU Worker: 전처리, 후처리 Activity                           │   │
│   │  • GPU Worker: 추론 Activity                                     │   │
│   │  • Heartbeat 패턴으로 장시간 작업 생존 신호                      │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                    │                                     │
│                                    ▼                                     │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  Inference Engines (ADR-002: Thin Wrapper 대상)                  │   │
│   │  ────────────────────────────────────────────                    │   │
│   │  • vLLM, Triton, 기타 추론 백엔드                                │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.2 장애 복구 시나리오

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   Durable Execution: 장애 복구 원리                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   시나리오: 추론 중 GPU Worker 크래시                                    │
│                                                                          │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  기존 방식 (Message Queue)                                       │   │
│   │  ──────────────────────────                                      │   │
│   │                                                                   │   │
│   │  [Pre ✓] ──▶ [Inference] ──✗ Worker 죽음                        │   │
│   │                     │                                             │   │
│   │                     └── Pre 결과 유실 → 전체 재시작 필요         │   │
│   │                                                                   │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  Temporal 방식 (Durable Execution)                               │   │
│   │  ─────────────────────────────────                               │   │
│   │                                                                   │   │
│   │  [Pre ✓] ──▶ [Inference] ──✗ Worker 죽음                        │   │
│   │     │               │                                             │   │
│   │     │               └── Heartbeat 타임아웃 감지                   │   │
│   │     │               └── Activity 실패로 기록                      │   │
│   │     │               └── Retry Policy에 따라 재스케줄              │   │
│   │     │                         │                                   │   │
│   │     └── 결과 보존됨 ──────────┘                                   │   │
│   │                               │                                   │   │
│   │                               ▼                                   │   │
│   │  [Pre 결과 재사용] ──▶ [Inference 재시도] ──▶ [Post] ──▶ 완료    │   │
│   │                                                                   │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
│   핵심 가치:                                                             │
│   ──────────                                                             │
│   • 이미 완료된 스테이지 재실행 없음 → GPU 비용 절감                     │
│   • 정확한 실패 지점 파악 → 디버깅 용이                                  │
│   • 자동 재시도 → 일시 장애에 강건                                       │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 4. 정책 원칙 (구현 가이드라인)

### 4.1 타임아웃 정책

구체적 수치는 구현 단계에서 결정하되, 다음 **의도(Intent)**를 반영해야 한다:

| 타임아웃 유형 | 정책 의도 |
|-------------|----------|
| **Schedule-to-Start** | GPU 워커 Cold Start와 스케일 아웃을 커버할 수 있는 충분한 여유 |
| **Start-to-Close** | 예상 최대 추론 시간의 1.5~2배 (모델/입력 크기에 따라 동적 조정) |
| **Heartbeat** | 스트리밍 중 워커 생존 확인 가능한 합리적 주기 |

### 4.2 재시도 정책

| 정책 요소 | 정책 의도 |
|----------|----------|
| **재시도 횟수** | 일시 장애(GPU OOM) 복구 기회 제공, 무한 재시도 방지 |
| **백오프 간격** | GPU 메모리 해제, 다른 워커 확보에 충분한 시간 |
| **비재시도 에러** | 입력 검증 실패, 인증 오류 등 재시도 무의미한 케이스 분류 |

### 4.3 이벤트 스트리밍 정책

| 이벤트 유형 | 전송 시점 | 목적 |
|------------|----------|------|
| **작업 시작** | Workflow 시작 즉시 | 클라이언트 연결 확인 |
| **단계 진행** | Activity 시작/완료 | 진행률 표시 |
| **토큰 스트리밍** | 토큰 생성 시마다 | 실시간 UX (ChatGPT 스타일) |
| **작업 완료/실패** | Workflow 종료 | 최종 결과 전달 |

---

## 5. 제약 조건: Determinism 원칙

> **"Temporal 채택은 Workflow 코드에 결정론(Determinism) 제약을 부과한다."**

### 5.1 결정론이란 무엇인가

Temporal Workflow는 장애 복구 시 **Event History를 기반으로 코드를 재실행(Replay)**하여 상태를 복원한다. 이 메커니즘이 정상 동작하려면, 동일한 입력에 대해 Workflow 코드가 **항상 동일한 순서로 동일한 명령을 생성**해야 한다.

### 5.2 금지되는 패턴

| 금지 패턴 | 이유 | 대안 |
|----------|------|------|
| **외부 I/O 직접 호출** | Replay 시 다른 결과 반환 가능 | Activity로 위임 |
| **현재 시간 직접 조회** | Replay 시 시간이 달라짐 | Workflow API 사용 |
| **랜덤 값 직접 생성** | Replay 시 값이 달라짐 | Workflow API 사용 |
| **전역 상태 의존** | 실행 환경에 따라 달라짐 | 입력 파라미터로 전달 |

### 5.3 위반 시 결과

결정론 위반 시 Temporal Worker는 **NonDeterministicError**를 발생시키고 해당 Workflow를 차단한다. 이는 런타임 장애이며, 사전 테스트로 발견하기 어렵다.

### 5.4 핵심 원칙

> **"Workflow는 오케스트레이션만 담당하고, 모든 부작용(Side Effect)은 Activity로 위임한다."**

---

## 6. 시스템 한계: Event History

### 6.1 Event History 크기 제한

Temporal의 Durable Execution은 모든 상태 변화를 Event로 기록한다. 이 Event History에는 크기 한계가 존재한다:

| 제한 | 값 | 영향 |
|------|-----|------|
| 최대 이벤트 수 | ~50,000 이벤트 | 초과 시 Workflow 실행 불가 |
| 최대 크기 | ~50MB | 초과 시 Workflow 실행 불가 |

### 6.2 영향받는 시나리오

- **무한 반복 파이프라인**: 주기적으로 실행되는 모니터링/스케줄링 Workflow
- **대규모 배치 처리**: 수천 개 아이템을 순차 처리하는 Workflow
- **장기 실행 Job**: 며칠~몇 주 동안 실행되는 Workflow

### 6.3 대응 전략: Continue-As-New

> **"History가 커지면, 현재 상태만 가지고 새 Workflow로 이어간다."**

Continue-As-New 패턴은 현재 Workflow 실행을 종료하고, 최신 상태를 입력으로 **새 Workflow 실행을 시작**한다. 이를 통해 History 크기를 초기화하면서 논리적으로는 연속된 실행을 유지한다.

**적용 기준**: 설계 단계에서 장기 실행 가능성이 있는 Workflow는 Continue-As-New를 고려한다.

---

## 7. Temporal의 근본적 한계

Temporal 채택 시 감수해야 할 **구조적 한계**를 명시한다. 이는 트레이드오프가 아닌, 시스템의 본질적 특성이다.

### 7.1 Payload 크기 제한 (2MB)

| 항목 | 내용 |
|------|------|
| **제한** | Workflow ↔ Activity 간 전달되는 Payload 최대 2MB |
| **영향** | 대용량 이미지, 긴 텍스트, 배치 결과를 직접 전달 불가 |

**아키텍처 원칙:**
> **"Temporal을 통해 대용량 데이터를 직접 전달하지 않는다. Payload에는 참조(Reference)만 전달하고, 실제 데이터는 외부 저장소를 통해 전달한다."**

```
금지: workflow.execute_activity(input=large_image_bytes)   ← 2MB 초과 위험
허용: workflow.execute_activity(input={"ref": "s3://..."}) ← 참조만 전달
```

### 7.2 실시간 스트리밍 경로 분리

| 항목 | 내용 |
|------|------|
| **제한** | Temporal은 모든 이벤트를 DB에 기록 — 토큰 단위 스트리밍에 부적합 |
| **영향** | SSE/WebSocket 실시간 푸시를 Temporal 경로로 처리 불가 |

**아키텍처 원칙:**
> **"Temporal은 오케스트레이션 경로, 스트리밍은 별도 경로로 분리한다."**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                       Dual Path Architecture                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  [클라이언트]                                                            │
│       │                                                                  │
│       ├── HTTP POST ──▶ [API] ──▶ [Temporal Workflow]                   │
│       │                              (Job 상태 관리)                     │
│       │                                   │                              │
│       │                                   ▼                              │
│       │                           [Inference Activity]                   │
│       │                                   │                              │
│       │                                   │ 토큰 스트리밍                │
│       │                                   ▼                              │
│       └── SSE ◀─────────────────── [Streaming Channel]                  │
│            (실시간 푸시)            (별도 채널 — ADR-005)                │
│                                                                          │
│  ─────────────────────────────────────────────────────────────────      │
│                                                                          │
│  Path 1 (Temporal): Job 상태, 단계 완료/실패 이벤트                     │
│  Path 2 (Direct):   토큰 단위 실시간 스트리밍 (Temporal 우회)           │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

**핵심 결정:**
- 실시간 토큰 스트리밍은 Temporal을 우회하여 클라이언트에 **직접 전달**한다
- Temporal에는 스트리밍 시작/완료 이벤트만 기록한다
- 스트리밍 채널의 구체적인 기술 선택은 **[ADR-005: 실시간 스트리밍 채널 전략](./005_Realtime_Streaming_Channel_Strategy.md)**에서 결정한다

### 7.3 Latency 오버헤드

| 항목 | 내용 |
|------|------|
| **특성** | 모든 Workflow 단계가 DB 트랜잭션을 거침 |
| **오버헤드** | 각 단계마다 수~수십 밀리초 추가 |
| **판단** | AI 추론(초 단위) >> Temporal 오버헤드(밀리초) — 수용 가능 |

**재검토 트리거**: 초저지연 요구사항 발생 시

### 7.4 운영 복잡도

| 컴포넌트 | 역할 |
|---------|------|
| Temporal Server | 4개 서비스 (Frontend, History, Matching, Worker) |
| Persistence DB | PostgreSQL/MySQL — Workflow 상태 저장 |
| Visibility Store | Elasticsearch — 검색/필터링 (선택) |
| Monitoring | Prometheus, Grafana |

**초기 전략 결정:**
> "Self-hosted로 시작하되, 운영 부담 증가 시 Temporal Cloud 전환을 검토한다."

---

## 8. 확장 패턴

본 섹션은 ADR 수준에서 결정할 **전략적 패턴**만 기술한다. 구체적 구현은 설계 문서에서 다룬다.

### 8.1 Child Workflow: 복잡 파이프라인 분할

| 항목 | 내용 |
|------|------|
| **용도** | 대규모 파이프라인을 독립적인 하위 Workflow로 분할 |
| **이점** | History 분산, 격리된 실패 도메인, 독립 재시도 |

**적용 기준:**
- 단일 Workflow의 Activity 수가 많아 History 한계 우려 시
- 하위 작업의 독립적 실패/재시도가 필요할 때

### 8.2 Saga 패턴: 보상 트랜잭션

| 항목 | 내용 |
|------|------|
| **용도** | 다단계 파이프라인 실패 시 이전 단계의 부작용을 취소 |
| **이점** | 분산 트랜잭션 없이 일관성 유지 |

**결정 필요 사항:**
> "파이프라인 실패 시 보상(Compensation)이 필요한가?"

| 시나리오 | 보상 필요 여부 |
|---------|---------------|
| 추론 결과가 외부 시스템에 기록되지 않음 | 불필요 — 단순 재시도로 충분 |
| 중간 단계에서 외부 API 호출/DB 기록 발생 | **필요** — 롤백 로직 설계 |

**초기 전략:**
> "Phase 1에서는 부작용 없는 순수 파이프라인으로 시작한다. 외부 부작용이 추가되는 시점에 Saga 패턴 도입을 검토한다."

---

## 9. 대안 비교 요약

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          Why Temporal?                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│                    Sync HTTP     Message Queue    Workflow Engine        │
│                    ─────────     ─────────────    ───────────────        │
│                                                                          │
│   긴 실행 시간       ❌ 타임아웃    ✅ 가능         ✅ 가능               │
│   지원               충돌                                                │
│                                                                          │
│   파이프라인         ❌ 없음       ⚠️ 직접 구현     ✅ 자동               │
│   상태 관리                        필요                                   │
│                                                                          │
│   장애 복구          ❌ 전체       ⚠️ Task 단위    ✅ 정확한 지점         │
│                      손실          (상태 유실)     재개                   │
│                                                                          │
│   개발 복잡도        ✅ 단순       ⚠️ 상태 관리    ⚠️ 학습 곡선          │
│                                    코드 필요                              │
│                                                                          │
│   운영 복잡도        ✅ 없음       ⚠️ Broker       ⚠️ Cluster            │
│                                    운영            운영                   │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────      │
│                                                                          │
│   결론:                                                                  │
│   • Sync HTTP: 구조적으로 부적합                                         │
│   • Message Queue: 상태 관리 코드를 우리가 짜야 함                       │
│   • Workflow Engine: 상태 관리를 위임, 복잡도 아웃소싱                   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 10. 트레이드오프 및 재검토 트리거

### 10.1 감수하는 단점

| 단점 | 영향 | 보완 전략 |
|------|------|----------|
| **운영 복잡도** | Temporal 클러스터 운영 필요 | Managed Service 또는 K8s Operator |
| **학습 곡선** | 팀의 Workflow 패턴 학습 필요 | 템플릿 제공, 내부 교육 |
| **벤더 결합** | Temporal에 종속 | 표준 패턴 사용, 추상화 레이어 |

### 10.2 재검토 트리거

다음 상황 발생 시 이 결정을 재검토한다:

- [ ] Temporal 운영 비용이 예상 대비 현저히 증가
- [ ] 팀 내 Temporal 전문성 확보 실패
- [ ] 서버리스 환경으로 전환 필요 (Worker 상주 불가)
- [ ] 더 나은 대안 기술 등장 및 안정화

---

## 11. 결론

### 11.1 최종 결정 요약

| 결정 항목 | 결정 내용 | 핵심 논거 |
|----------|----------|----------|
| **실행 모델** | 비동기 워크플로우 | 동기 HTTP의 구조적 한계 회피 |
| **상태 관리** | Workflow Engine 위임 | 복잡도 아웃소싱, 개발자 부담 감소 |
| **결과 전달** | SSE 푸시 스트리밍 | 실시간 UX, 폴링 대비 효율 |

### 11.2 핵심 메시지

> **"Temporal 도입은 오버 엔지니어링이 아니다. 우리가 직접 짜야 할 상태 관리 코드를 전문 엔진에 위임하는 복잡도 아웃소싱이다. AI 추론의 본질적 특성(긴 실행, 빈번한 장애, 다단계 처리)에 대한 구조적 해답이다."**

---

## 관련 문서 (Related)

- [ADR-001: AI 서비스 엔드포인트 외부 노출](./001_How_to_Securely_Expose_AI_API_Endpoint_[Nginx%20OSS].md) - Edge Layer
- [ADR-002: AI 백엔드 범위 및 아키텍처 스타일](./002_Defining_Scope_and_Architecture_Style_of_AI_Backend_Application.md) - 파이프라인 정의
- 02_architecture/04_worker.md - Temporal Worker 상세 설계 (구현 시 작성)
- 04_operations/01_temporal.md - Temporal 운영 가이드 (구현 시 작성)

---

## 변경 이력 (Changelog)

| 날짜 | 작성자 | 변경 내용 |
|------|--------|----------|
| 2024-12-27 | System Architect | 초안 작성 — 실행 모델, Temporal 채택, SSE 스트리밍 결정 |
| 2024-12-27 | System Architect | 추상화 레벨 상향 — 구현 세부사항 제거, 전략적 의사결정 중심으로 재구성 |
| 2024-12-27 | System Architect | 제약/한계/리스크 보완 — Determinism, Event History 한계, Payload 2MB, SSE 경로 분리, 확장 패턴 추가 |
| 2024-12-27 | System Architect | Dual Path 원칙 명확화 — 스트리밍 채널 구현을 ADR-005로 위임, 구체적 기술 선택 제거 |
