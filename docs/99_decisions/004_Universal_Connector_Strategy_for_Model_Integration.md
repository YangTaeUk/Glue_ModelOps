# ADR-004: 다양한 모델 연동을 위한 유니버설 커넥터 전략

> **Status**: Accepted
> **Date**: 2024-12-27
> **Author**: System Architect
> **Context**: ADR-003(Temporal 워크플로우) 후속 결정 — 외부 모델 통신 추상화
> **Supersedes**: N/A

---

## TL;DR (한 줄 요약)

> 우리 시스템은 모델을 "서빙"하지 않고 **"통신"**할 뿐이다. 다양한 프로토콜(REST, WebSocket, gRPC)과 벤더별 응답 포맷을 **Connector Pattern**과 **Event Normalizer**로 추상화하여, 파이프라인 코어가 특정 백엔드에 종속되지 않게 한다.

---

## 1. 문제 정의: 프로토콜과 포맷의 파편화

### 1.1 우리 시스템의 위치

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     시스템 경계 명확화                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   우리가 하는 것:                    우리가 하지 않는 것:                │
│   ─────────────────                  ─────────────────────               │
│                                                                          │
│   ✓ 모델과 "통신(Communication)"    ✗ 모델을 "서빙(Serving)"            │
│   ✓ 파이프라인 오케스트레이션        ✗ GPU 관리, 배치 최적화            │
│   ✓ 프로토콜 추상화                  ✗ 추론 엔진 내부 최적화            │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────      │
│                                                                          │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  우리 시스템 (Pipeline Manager)                                  │   │
│   │  ────────────────────────────────                                │   │
│   │                      │                                           │   │
│   │                      ▼                                           │   │
│   │              ┌───────────────┐                                   │   │
│   │              │   Connector   │  ◀── 본 ADR의 핵심                │   │
│   │              └───────────────┘                                   │   │
│   │                      │                                           │   │
│   └──────────────────────┼──────────────────────────────────────────┘   │
│                          │                                               │
│                          ▼                                               │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  외부 추론 백엔드들 (우리 통제 밖)                               │   │
│   │  ──────────────────────────────────                              │   │
│   │  [vLLM] [Triton] [OpenAI API] [Anthropic] [Self-hosted]         │   │
│   │  REST     gRPC     REST/SSE     REST/SSE    WebSocket            │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

**핵심 원칙: Backend Agnostic**
> 우리는 특정 추론 엔진을 표준으로 삼거나 강제하지 않는다. vLLM이든, Triton이든, 외부 SaaS든 — 모두 동등하게 연결 가능해야 한다.

### 1.2 프로토콜 파편화 현실

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   외부 모델 통신의 현실                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   "세상의 모든 모델이 같은 언어를 말하지 않는다"                         │
│                                                                          │
│   ┌───────────────────────────────────────────────────────────────┐     │
│   │  프로토콜 다양성                                               │     │
│   │  ─────────────────                                             │     │
│   │                                                                 │     │
│   │  • REST/HTTP: OpenAI, Anthropic, HuggingFace Inference API     │     │
│   │  • WebSocket: 일부 실시간 추론 서버                             │     │
│   │  • gRPC: Triton Inference Server, TensorFlow Serving           │     │
│   │  • 독자 프로토콜: 사내 레거시 시스템                             │     │
│   └───────────────────────────────────────────────────────────────┘     │
│                                                                          │
│   ┌───────────────────────────────────────────────────────────────┐     │
│   │  스트리밍 응답 포맷 다양성                                      │     │
│   │  ─────────────────────────                                      │     │
│   │                                                                 │     │
│   │  • 벤더마다 다른 JSON 구조와 필드명 사용                        │     │
│   │  • 완료/에러 시그널 표현 방식 상이                              │     │
│   │  • 메타데이터 (토큰 수, 지연 시간 등) 위치 다름                 │     │
│   │  • 사내 레거시 시스템은 독자적 포맷 사용                        │     │
│   └───────────────────────────────────────────────────────────────┘     │
│                                                                          │
│   ┌───────────────────────────────────────────────────────────────┐     │
│   │  연결 특성 다양성                                               │     │
│   │  ────────────────                                               │     │
│   │                                                                 │     │
│   │  REST:      요청당 연결 (Ephemeral) — 간단, 비용 낮음           │     │
│   │  WebSocket: 장기 연결 (Persistent) — 연결 비용 높음             │     │
│   │  gRPC:      연결 풀링 권장 (Pooled) — 재사용 효율적             │     │
│   └───────────────────────────────────────────────────────────────┘     │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.3 이 문제를 방치하면

| 방치 시 결과 | 영향 |
|-------------|------|
| **코드 중복** | 각 Activity마다 프로토콜별 통신 코드 산재 |
| **벤더 종속** | 파이프라인 로직이 특정 모델 응답 포맷에 결합 |
| **변경 비용** | 새 모델 추가 시 코어 파이프라인 수정 필요 |
| **테스트 복잡** | 프로토콜별 Mock 코드 중복 |

---

## 2. 전략적 결정: 세 가지 핵심 원칙

### 2.1 결정 #1: Connector Pattern — 통신 추상화

> **"파이프라인 Activity 코드에 직접 통신 로직을 작성하지 않는다."**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   Connector Pattern: 통신 책임 분리                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ❌ 금지: Activity 내부에 통신 코드 직접 작성                           │
│   ──────────────────────────────────────────                             │
│                                                                          │
│   Activity 코드에서:                                                     │
│   • requests.post("http://model-server/generate", ...)  ← 금지          │
│   • websocket.connect("ws://realtime-model/stream")     ← 금지          │
│   • grpc_stub.Predict(request)                          ← 금지          │
│                                                                          │
│   문제점:                                                                │
│   • 프로토콜 변경 시 모든 Activity 수정 필요                             │
│   • 모델 서버 URL 하드코딩                                               │
│   • 테스트 시 실제 네트워크 호출 발생                                    │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────      │
│                                                                          │
│   ✓ 허용: Unified Connector Interface를 통한 호출                       │
│   ─────────────────────────────────────────────                          │
│                                                                          │
│   Activity 코드에서:                                                     │
│   • connector.invoke(request, config)                   ← 허용          │
│   • connector.stream(request, config) → AsyncIterator   ← 허용          │
│                                                                          │
│   이점:                                                                  │
│   • Activity는 "무엇을 요청할지"만 정의                                  │
│   • "어떻게 통신할지"는 Connector가 결정                                 │
│   • 프로토콜 변경 시 Connector만 교체                                    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

**Connector Interface 설계 원칙:**

| 원칙 | 설명 |
|------|------|
| **단일 책임** | Connector는 통신만 담당, 비즈니스 로직 없음 |
| **Protocol Agnostic** | 상위 계층은 프로토콜을 모름 (알 필요 없음) |
| **Pluggable** | 새 프로토콜 = 새 Adapter 추가 (OCP 준수) |

---

### 2.2 결정 #2: Event Normalizer — 응답 포맷 정규화

> **"외부 모델의 응답 포맷이 제각각이더라도, 파이프라인 내부에서는 하나의 표준 형식으로 흐른다."**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   Event Normalizer: 응답 포맷 표준화                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   외부 세계 (제각각)                    내부 세계 (표준화)               │
│   ──────────────────                    ────────────────                 │
│                                                                          │
│   OpenAI Format ─────┐                                                   │
│                      │                                                   │
│   Anthropic Format ──┼──▶ [Normalizer] ──▶ Standard Pipeline Event     │
│                      │                                                   │
│   Custom Format ─────┘                                                   │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────      │
│                                                                          │
│   정규화 대상:                                                           │
│   ─────────────                                                          │
│                                                                          │
│   ┌───────────────────────────────────────────────────────────────┐     │
│   │  1. 스트리밍 토큰 이벤트                                       │     │
│   │     ─────────────────────                                      │     │
│   │     • OpenAI delta → Standard Token Event                     │     │
│   │     • Anthropic delta → Standard Token Event                  │     │
│   │     • vLLM text → Standard Token Event                        │     │
│   │                                                                 │     │
│   │  2. 완료/에러 시그널                                           │     │
│   │     ─────────────────                                          │     │
│   │     • finish_reason, stop_reason, error → Standard Completion │     │
│   │                                                                 │     │
│   │  3. 메타데이터                                                  │     │
│   │     ───────────                                                 │     │
│   │     • usage, latency, model_id → Standard Metadata             │     │
│   └───────────────────────────────────────────────────────────────┘     │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────      │
│                                                                          │
│   이점:                                                                  │
│   ──────                                                                 │
│   • 후처리(Post-processing) 로직이 모델 벤더에 종속되지 않음             │
│   • 새 모델 추가 시 Normalizer만 작성, 파이프라인 로직 변경 없음         │
│   • 로깅/모니터링 포맷 일관성 확보                                       │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

**정규화 책임 위치:**
> Normalizer는 **Connector 내부**에 위치한다. 외부 응답이 Connector를 빠져나오는 순간, 이미 표준 포맷이다.

---

### 2.3 결정 #3: Connection Strategy — 프로토콜별 연결 관리

> **"연결 방식은 프로토콜 특성에 따라 다르게 적용할 수 있어야 한다."**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   Connection Strategy: 프로토콜별 최적화                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   프로토콜마다 최적의 연결 관리 방식이 다르다.                           │
│   단일 전략을 강제하지 않고, 프로토콜 특성에 맞는 선택을 허용한다.       │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────      │
│                                                                          │
│   ┌───────────────────────────────────────────────────────────────┐     │
│   │  Ephemeral (일회성 연결)                                       │     │
│   │  ───────────────────────                                       │     │
│   │                                                                 │     │
│   │  적합: REST/HTTP                                               │     │
│   │  특징: 요청마다 새 연결, 상태 없음, 단순                        │     │
│   │  비용: 연결 오버헤드 있으나 HTTP Keep-Alive로 완화             │     │
│   └───────────────────────────────────────────────────────────────┘     │
│                                                                          │
│   ┌───────────────────────────────────────────────────────────────┐     │
│   │  Pooled (연결 풀)                                              │     │
│   │  ────────────────                                              │     │
│   │                                                                 │     │
│   │  적합: gRPC, 고빈도 HTTP                                       │     │
│   │  특징: 연결 재사용, 풀 크기 관리                                │     │
│   │  비용: 리소스 점유, 풀 관리 로직 필요                           │     │
│   └───────────────────────────────────────────────────────────────┘     │
│                                                                          │
│   ┌───────────────────────────────────────────────────────────────┐     │
│   │  Persistent (장기 연결)                                        │     │
│   │  ─────────────────────                                         │     │
│   │                                                                 │     │
│   │  적합: WebSocket, 양방향 스트리밍                               │     │
│   │  특징: 연결 유지, heartbeat, 재연결 로직 필요                   │     │
│   │  비용: 연결 관리 복잡, 상태 유지                                │     │
│   └───────────────────────────────────────────────────────────────┘     │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────      │
│                                                                          │
│   결정:                                                                  │
│   ──────                                                                 │
│   연결 전략은 Connector Adapter 내부에서 결정한다.                       │
│   상위 계층(Activity)은 연결 방식을 알지 못하고, 알 필요도 없다.         │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 3. 아키텍처 개요

### 3.1 Connector Adapter 구조

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     Connector Architecture                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  Temporal Activity (Pipeline Stage)                              │   │
│   │  ────────────────────────────────────                            │   │
│   │                                                                   │   │
│   │  • 비즈니스 로직에만 집중                                        │   │
│   │  • connector.invoke() 또는 connector.stream() 호출               │   │
│   │  • 프로토콜/포맷 무관                                            │   │
│   │                                                                   │   │
│   └───────────────────────────────┬─────────────────────────────────┘   │
│                                   │                                      │
│                                   ▼                                      │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  Unified Connector Interface                                     │   │
│   │  ────────────────────────────                                    │   │
│   │                                                                   │   │
│   │  지원해야 할 능력 (Capabilities):                                │   │
│   │  • 단일 요청-응답 호출                                           │   │
│   │  • 스트리밍 응답 수신 (비동기 이터레이터)                        │   │
│   │  • 연결 상태 확인 (헬스체크)                                     │   │
│   │                                                                   │   │
│   │  (구체적인 메서드 시그니처는 설계 문서에서 정의)                 │   │
│   │                                                                   │   │
│   └───────────────────────────────┬─────────────────────────────────┘   │
│                                   │                                      │
│               ┌───────────────────┼───────────────────┐                 │
│               │                   │                   │                 │
│               ▼                   ▼                   ▼                 │
│   ┌───────────────────┐ ┌───────────────────┐ ┌───────────────────┐    │
│   │  REST Adapter     │ │  gRPC Adapter     │ │  WebSocket Adapter│    │
│   │  ──────────────   │ │  ──────────────   │ │  ────────────────│    │
│   │                   │ │                   │ │                   │    │
│   │  • HTTP Client    │ │  • gRPC Stub      │ │  • WS Client      │    │
│   │  • SSE Parser     │ │  • Protobuf       │ │  • Reconnection   │    │
│   │  • Ephemeral Conn │ │  • Pooled Conn    │ │  • Persistent Conn│    │
│   │                   │ │                   │ │                   │    │
│   │  ┌─────────────┐  │ │  ┌─────────────┐  │ │  ┌─────────────┐  │    │
│   │  │ Normalizer  │  │ │  │ Normalizer  │  │ │  │ Normalizer  │  │    │
│   │  └─────────────┘  │ │  └─────────────┘  │ │  └─────────────┘  │    │
│   └───────────────────┘ └───────────────────┘ └───────────────────┘    │
│               │                   │                   │                 │
│               ▼                   ▼                   ▼                 │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  External Model Servers                                          │   │
│   │  ───────────────────────                                         │   │
│   │  [OpenAI] [Anthropic] [vLLM] [Triton] [Custom Server]           │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.2 데이터 흐름

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     Request/Response Flow                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   [요청 흐름]                                                            │
│   ───────────                                                            │
│                                                                          │
│   Activity                                                               │
│      │                                                                   │
│      │  StandardRequest (모델 무관한 표준 요청)                          │
│      ▼                                                                   │
│   Connector Interface                                                    │
│      │                                                                   │
│      │  Config 기반 Adapter 선택                                         │
│      ▼                                                                   │
│   Protocol Adapter                                                       │
│      │                                                                   │
│      │  표준 요청 → 프로토콜별 요청 변환                                 │
│      ▼                                                                   │
│   External Model Server                                                  │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────      │
│                                                                          │
│   [응답 흐름 - 스트리밍]                                                 │
│   ──────────────────────                                                 │
│                                                                          │
│   External Model Server                                                  │
│      │                                                                   │
│      │  Vendor-specific 스트리밍 응답                                    │
│      ▼                                                                   │
│   Protocol Adapter                                                       │
│      │                                                                   │
│      │  Normalizer: 벤더 포맷 → Standard Event 변환                      │
│      ▼                                                                   │
│   Connector Interface                                                    │
│      │                                                                   │
│      │  AsyncIterator[StandardEvent] 반환                                │
│      ▼                                                                   │
│   Activity                                                               │
│      │                                                                   │
│      │  표준 이벤트만 처리 (벤더 무관)                                   │
│      ▼                                                                   │
│   Pipeline Context (metadata 누적)                                       │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.3 새 모델 추가 시 변경 범위

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     확장 시나리오: 새 모델 백엔드 추가                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   시나리오: "XYZ 모델 서버"를 새로 연동해야 한다.                        │
│             XYZ는 독자 프로토콜 + 독자 응답 포맷을 사용한다.             │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────      │
│                                                                          │
│   변경이 필요한 것:                                                      │
│   ─────────────────                                                      │
│                                                                          │
│   ┌───────────────────────────────────────────────────────────────┐     │
│   │  1. XYZ Adapter 신규 작성                                      │     │
│   │     • XYZ 프로토콜 연결 로직                                   │     │
│   │     • XYZ 응답 → Standard Event Normalizer                    │     │
│   │                                                                 │     │
│   │  2. Connector 설정에 XYZ Adapter 등록                          │     │
│   │     • model_type: xyz → XYZAdapter                             │     │
│   └───────────────────────────────────────────────────────────────┘     │
│                                                                          │
│   변경이 필요 없는 것:                                                   │
│   ───────────────────                                                    │
│                                                                          │
│   ┌───────────────────────────────────────────────────────────────┐     │
│   │  ✓ Temporal Activity 코드                                      │     │
│   │  ✓ Pipeline 정의                                               │     │
│   │  ✓ 전/후처리 Handler                                           │     │
│   │  ✓ Context Propagation 로직                                    │     │
│   │  ✓ SSE 스트리밍 로직                                           │     │
│   │  ✓ 기존 다른 Adapter들                                         │     │
│   └───────────────────────────────────────────────────────────────┘     │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────      │
│                                                                          │
│   결과: OCP(Open-Closed Principle) 준수                                  │
│   ────                                                                   │
│   "확장에는 열려 있고, 수정에는 닫혀 있다"                               │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 4. 책임 경계와 신뢰성 원칙

### 4.1 Connector-Activity 책임 분리

> **"Connector는 통신만 담당하고, 재시도 정책은 Temporal에 위임한다."**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   책임 경계 정의                                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   Connector의 책임:                    Temporal Activity의 책임:        │
│   ──────────────────                   ───────────────────────          │
│                                                                          │
│   • 프로토콜별 연결 관리               • 재시도 정책 (Retry Policy)      │
│   • 요청/응답 변환                     • 타임아웃 관리                   │
│   • 스트리밍 수신                      • 실패 기록 및 복구               │
│   • 응답 정규화                        • Heartbeat 전송                  │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────      │
│                                                                          │
│   원칙:                                                                  │
│   ──────                                                                 │
│   • Connector 내부에서 자체 재시도 로직을 구현하지 않는다               │
│   • 통신 실패 시 예외를 상위(Activity)로 전파한다                       │
│   • Temporal이 Retry Policy에 따라 Activity 전체를 재실행한다           │
│                                                                          │
│   이유:                                                                  │
│   ──────                                                                 │
│   • 재시도 로직 중복 방지 (Connector + Temporal 이중 재시도)            │
│   • 재시도 상태가 Event History에 기록되어 추적 가능                    │
│   • 일관된 재시도 정책 관리 (Temporal 설정으로 중앙화)                  │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

**에러 분류 책임:**

| 책임 주체 | 역할 |
|----------|------|
| **Connector** | 벤더별 에러 코드를 표준 예외 타입으로 변환 |
| **Activity 설정** | Non-Retryable Error 목록 정의 (Temporal 설정) |
| **Temporal** | 에러 타입에 따라 재시도 여부 결정 |

### 4.2 스트리밍 장애 감지 원칙

> **"장시간 스트리밍 Activity는 반드시 Heartbeat를 사용한다."**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   스트리밍 장애 감지 문제                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   문제 상황:                                                            │
│   ──────────                                                            │
│   GPU 추론 스트리밍이 5분 동안 진행 중...                               │
│   → 3분 시점에 Worker 프로세스 갑자기 종료                              │
│   → Temporal Server는 이를 어떻게 알 수 있는가?                         │
│                                                                          │
│   Heartbeat 없이:                       Heartbeat 사용 시:              │
│   ────────────────                      ────────────────────            │
│   Start-To-Close 타임아웃까지 대기      Heartbeat 타임아웃 감지         │
│   (5분 전체 대기)                       (수십 초 내 감지)               │
│   → 장애 감지 지연                      → 빠른 재시도 가능              │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

**아키텍처 원칙:**

| 원칙 | 설명 |
|------|------|
| **Heartbeat 필수** | 스트리밍 Activity는 주기적으로 Temporal에 생존 신호 전송 |
| **Connector 통합** | 스트리밍 수신 루프 내에서 Heartbeat 호출 |
| **진행률 전달** | Heartbeat에 현재 진행률 포함 (선택) |

**Connector와 Heartbeat 통합:**

```
스트리밍 수신 루프:

while streaming:
    chunk = connector.receive_chunk()    ← Connector 책임
    process(chunk)
    heartbeat(progress=current_progress)  ← Activity 책임 (Temporal API)
```

---

## 5. ADR 체계 내 위치

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     ADR 의존 관계                                        │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ADR-001: Edge Layer (Nginx)                                           │
│      │    외부 트래픽 수신                                               │
│      ▼                                                                   │
│   ADR-002: Pipeline Manager                                              │
│      │    선형 파이프라인, Context Propagation                           │
│      ▼                                                                   │
│   ADR-003: Execution Model (Temporal)                                    │
│      │    비동기 워크플로우, Durable Execution                           │
│      ▼                                                                   │
│   ADR-004: Universal Connector (본 문서)                                 │
│      │    외부 모델 통신 추상화                                          │
│      │                                                                   │
│      └───▶ Activity → Connector → External Model                        │
│                                                                          │
│   ─────────────────────────────────────────────────────────────────      │
│                                                                          │
│   핵심 연결:                                                             │
│   ──────────                                                             │
│   • ADR-003의 Activity가 ADR-004의 Connector를 사용                      │
│   • ADR-002의 Context가 Connector를 통과해도 보존됨                      │
│   • ADR-001의 Edge를 통해 들어온 요청이 최종적으로 Connector로 나감      │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 6. 트레이드오프 및 위험 요소

### 6.1 감수하는 단점

| 단점 | 영향 | 보완 전략 |
|------|------|----------|
| **추상화 오버헤드** | 간접 호출 레이어 추가 | 성능 크리티컬 경로 최소화 |
| **Adapter 유지보수** | 각 프로토콜별 Adapter 관리 필요 | 공통 로직 베이스 클래스로 추출 |
| **표준 이벤트 제약** | 일부 벤더 고유 기능 손실 가능 | 확장 가능한 메타데이터 필드 제공 |

### 6.2 재검토 트리거

다음 상황 발생 시 이 결정을 재검토한다:

- [ ] 지원해야 할 프로토콜이 급격히 증가하여 Adapter 관리 비용이 과도해질 때
- [ ] 성능 병목이 Connector 레이어에서 발생할 때
- [ ] 벤더 고유 기능이 표준 이벤트로 표현 불가능할 때

---

## 7. 결론

### 7.1 최종 결정 요약

| 결정 항목 | 결정 내용 | 핵심 논거 |
|----------|----------|----------|
| **Connector Pattern** | 통신 로직을 Adapter로 분리 | 파이프라인 코어의 프로토콜 독립성 확보 |
| **Event Normalizer** | 벤더 응답을 내부 표준으로 변환 | 후처리 로직의 벤더 종속 방지 |
| **Connection Strategy** | 프로토콜별 연결 전략 허용 | 다양한 프로토콜 특성에 맞는 최적화 가능 |

### 7.2 핵심 메시지

> **"우리 시스템은 모델이 어디에 있든, 어떤 언어(프로토콜)로 말하든 상관없이 연결할 수 있다. Connector가 번역을 담당하고, 파이프라인은 표준 언어만 사용한다."**

---

## 관련 문서 (Related)

**선행 결정:**
- [ADR-001: AI 서비스 엔드포인트 외부 노출](./001_How_to_Securely_Expose_AI_API_Endpoint_[Nginx%20OSS].md) — Edge Layer
- [ADR-002: AI 백엔드 범위 및 아키텍처 스타일](./002_Defining_Scope_and_Architecture_Style_of_AI_Backend_Application.md) — 파이프라인 정의
- [ADR-003: 추론 작업 실행 모델](./003_Inference_Task_Execution_Model_and_State_Management_Strategy.md) — Temporal 워크플로우, Activity 개념

**후속 결정 (본 ADR의 Connector를 누가/어디서 호출하는지 구체화):**
- [ADR-006: Worker 리소스 분리](./006_Worker_Resource_Separation_and_Parallel_Processing_Strategy.md) — Accelerator Worker가 Connector로 추론 요청
- [ADR-007: 추론 서버 배포 경계](./007_Inference_Server_Deployment_and_Worker_Communication_Boundary.md) — Connector가 통신할 추론 서버의 배포 책임

---

## 변경 이력 (Changelog)

| 날짜 | 작성자 | 변경 내용 |
|------|--------|----------|
| 2024-12-27 | System Architect | 초안 작성 — Connector Pattern, Event Normalizer, Connection Strategy 결정 |
| 2024-12-27 | System Architect | Diet 리팩토링 — 벤더별 JSON 포맷 예시 제거, 추상 설명으로 대체 |
| 2024-12-27 | System Architect | Why/What 원칙 준수 — 메서드 시그니처를 Capabilities로 대체 |
| 2024-12-27 | System Architect | 책임 경계/신뢰성 보완 — Connector-Activity 책임 분리, 스트리밍 장애 감지 원칙 추가 |
